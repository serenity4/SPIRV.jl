mutable struct CacheDiagnostics
  @atomic hits::Int
  @atomic misses::Int
end
CacheDiagnostics() = CacheDiagnostics(0, 0)

mutable struct Cache{D}
  const d::D
  @atomic diagnostics::CacheDiagnostics
end
Cache{D}() where {D} = Cache{D}(D(), CacheDiagnostics())

Base.deepcopy_internal(cache::Cache, ::IdDict) = typeof(cache)(deepcopy(cache.d), deepcopy(cache.diagnostics))

function Base.empty!(cache::Cache)
  empty!(cache.d)
  @atomic :monotonic cache.diagnostics = CacheDiagnostics()
  cache
end

@forward_methods Cache field = :d Base.haskey(_, key) Base.iterate(_, args...) Base.length Base.keys Base.getindex(_, key)

function Base.get!(f, cache::Cache, key)
  if haskey(cache, key)
    @atomic :monotonic cache.diagnostics.hits += 1
    cache.d[key]
  else
    @atomic :monotonic cache.diagnostics.misses += 1
    get!(f, cache.d, key)
  end
end

function Base.get(f, cache::Cache, key)
  if haskey(cache, key)
    @atomic :monotonic cache.diagnostics.hits += 1
    cache[key]
  else
    @atomic :monotonic cache.diagnostics.misses += 1
    f()
  end
end

Base.get!(cache::Cache, key, default) = get!(() -> default, cache, key)
Base.get(cache::Cache, key, default) = get(() -> default, cache, key)

"""
    ShaderCompilationCache()

Create a cache that may be used to associate shaders to be compiled ([`ShaderInfo`](@ref)) with
compiled code ([`ShaderSource`](@ref)).

Although this cache will already significantly speed up shader creation by compiling only what is required,
performance-critical applications will additionally want to use a high-level cache that maps a [`ShaderSource`](@ref)
to a driver-dependent object generated by the graphics API chosen for that application.
For Vulkan, that would be a `Vk.ShaderModule`, for example. It is then recommended to use an `IdDict` to perform the caching,
to avoid hashing the whole source code.

!!! warning
    Caching assumes the same [`SPIRVInterpreter`](@ref) to be used, and will not look into the `ShaderSource`'s `interp` field. Generally, applications should use a single interpreter, and not fiddle with parameters across different shader compilation runs. This allows caching to skip hashing `SPIRVInterpreter` contents needlessly in what should be >99.9% of cases.
"""
const ShaderCompilationCache = Cache{Dict{UInt64,ShaderSource}}

function cache_token(info::ShaderInfo)
  h = hash(ShaderInfo)
  h = hash(info.mi, h)
  h = hash(info.interface, h)
  h = hash(info.layout.alignment, h)
  h
end

# The cache could be reused across devices, if we want to avoid going through codegen again.
# However the supported features would have to be taken as the intersection of all the supported
# ones on each hypothetical device.

ShaderSource(cache::ShaderCompilationCache, info::ShaderInfo; validate = true, optimize = false) = get!(cache, info; validate, optimize)
ShaderSource(cache::Nothing, info::ShaderInfo; validate = true, optimize = false) = ShaderSource(info; validate, optimize)
Base.get!(cache::ShaderCompilationCache, info::ShaderInfo; validate = true, optimize = false) = get!(() -> ShaderSource(info; validate, optimize), cache, cache_token(info))
