<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Executing a shader · SPIRV.jl</title><meta name="title" content="Executing a shader · SPIRV.jl"/><meta property="og:title" content="Executing a shader · SPIRV.jl"/><meta property="twitter:title" content="Executing a shader · SPIRV.jl"/><meta name="description" content="Documentation for SPIRV.jl."/><meta property="og:description" content="Documentation for SPIRV.jl."/><meta property="twitter:description" content="Documentation for SPIRV.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">SPIRV.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SPIRV.jl</a></li><li><a class="tocitem" href="../../intro/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../manipulating_spirv/">Manipulating SPIR-V binaries</a></li><li><a class="tocitem" href="../creating_a_shader/">Creating a shader</a></li><li class="is-active"><a class="tocitem" href>Executing a shader</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../reference/shader_compilation/">Julia → SPIR-V compiler</a></li><li><a class="tocitem" href="../../reference/bit_width/">Integer and float bit widths</a></li><li><a class="tocitem" href="../../reference/known_bugs/">Known bugs</a></li></ul></li><li><a class="tocitem" href="../../features/">Features</a></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../../devdocs/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Executing a shader</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Executing a shader</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/serenity4/SPIRV.jl/blob/main/docs/src/tutorials/executing_a_shader.jl#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Executing-a-shader"><a class="docs-heading-anchor" href="#Executing-a-shader">Executing a shader</a><a id="Executing-a-shader-1"></a><a class="docs-heading-anchor-permalink" href="#Executing-a-shader" title="Permalink"></a></h1><p>After <a href="../creating_a_shader/#tutorial-creating-a-shader">creating and compiling shaders</a>, the next logical step is executing them. Thsi requires the help of a graphics API that uses SPIR-V, such as Vulkan or OpenGL (with the <a href="https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gl_spirv.txt">corresponding SPIR-V extension</a>). We will use Vulkan through Vulkan.jl.</p><p>As Vulkan usage falls out of scope of this documentation, we will not detail nor comment the steps used to setup everything, beyond inline code comments. For resources about Vulkan API usage, please consult the <a href="https://juliagpu.github.io/Vulkan.jl/dev/">Vulkan.jl documentation</a>.</p><p>First, we need to interface with the Vulkan loader with a <code>Vk.Instance</code>, and pick a device for shader execution.</p><pre><code class="language- hljs">using SPIRV: SupportedFeatures, check_compiler_feature_requirements
using Vulkan: Vk, VkCore, unwrap</code></pre><p>Create callback for logging and error reporting.</p><pre><code class="language- hljs">debug_callback_c = @cfunction(Vk.default_debug_callback, UInt32, (Vk.DebugUtilsMessageSeverityFlagEXT, Vk.DebugUtilsMessageTypeFlagEXT, Ptr{VkCore.VkDebugUtilsMessengerCallbackDataEXT}, Ptr{Cvoid}))

function create_device()
  # Use the validation layers.
  layers = String[&quot;VK_LAYER_KHRONOS_validation&quot;]
  # Enable logging.
  extensions = String[&quot;VK_EXT_debug_utils&quot;]
  instance = Vk.Instance(layers, extensions; application_info = Vk.ApplicationInfo(v&quot;0.1&quot;, v&quot;0.1&quot;, v&quot;1.3&quot;))
  debug_messenger = Vk.DebugUtilsMessengerEXT(instance, debug_callback_c)

  # Pick the first physical device that we find.
  physical_device = first(unwrap(Vk.enumerate_physical_devices(instance)))
  @info &quot;Selected $(Vk.get_physical_device_properties(physical_device))&quot;

  # Request Vulkan API features necessary for the usage with SPIRV.jl
  device_features_1_1 = Vk.PhysicalDeviceVulkan11Features(:variable_pointers, :variable_pointers_storage_buffer)
  device_features_1_2 = Vk.PhysicalDeviceVulkan12Features(:buffer_device_address, :vulkan_memory_model; next = device_features_1_1)
  device_features_1_3 = Vk.PhysicalDeviceVulkan13Features(:synchronization2, :dynamic_rendering, :shader_integer_dot_product, :maintenance4; next = device_features_1_2)
  device_features = Vk.PhysicalDeviceFeatures2(Vk.PhysicalDeviceFeatures(:shader_float_64, :shader_int_64); next = device_features_1_3)

  # Create the device requesting a queue that supports graphics and compute operations.
  device_extensions = String[]
  queue_family_index = Vk.find_queue_family(physical_device, Vk.QUEUE_GRAPHICS_BIT | Vk.QUEUE_COMPUTE_BIT)
  device = Vk.Device(
    physical_device,
    [Vk.DeviceQueueCreateInfo(queue_family_index, [1.0])],
    [], device_extensions; next = device_features
  )

  # Query all of the supported SPIR-V features, to be communicated to the Julia → SPIR-V compiler.
  supported_features = SupportedFeatures(physical_device, v&quot;1.3&quot;, device_extensions, device_features)
  # Check that we have the basic features that the compiler will require.
  check_compiler_feature_requirements(supported_features)

  (; debug_messenger, device, queue_family_index, supported_features)
end

(; debug_messenger, device, queue_family_index, supported_features) = create_device();
nothing #hide</code></pre><p>Great. Now, we need to think about what we&#39;re going to do. We will first execute a compute shader, taking the one from the previous tutorial.</p><p>This time, we&#39;ll create a <a href="../../api/#SPIRV.ShaderSource"><code>SPIRV.ShaderSource</code></a>, which represents a <a href="@ref"><code>SPIRV.Shader</code></a> assembled into a word vector, using the macro parameter <code>assemble = true</code>. We&#39;ll also fill in the <code>features</code> parameter, such that we are guaranteed that the Julia → SPIR-V compiler returns a shader that is compatible with our Vulkan API usage.</p><pre><code class="language- hljs">source = @compute features = supported_features assemble = true compute_shader!(
  ::ComputeData::PushConstant,
  ::Vec3U::Input{GlobalInvocationId},
  ) options = ComputeExecutionOptions(local_size = (64, 1, 1))</code></pre><p>To submit our shader for execution, we first need to:</p><ul><li>Provide Vulkan with our shader.</li><li>Construct a buffer on the device that holds our <code>Vector</code> data, then get its memory address.</li><li>Build a command buffer and submit the appropriate commands to invoke our compute shader.</li><li>Wait for the computation to finish and copy the results into our original <code>Vector</code>.</li></ul><p>This is all quite verbose, but with Vulkan, this is normal.</p><pre><code class="language- hljs">using SPIRV: ShaderSource, serialize

&quot;&quot;&quot;
Execute a shader on the provided device and return the result, which **must** be of type `T`.
&quot;&quot;&quot;
function execute_shader(source::ShaderSource, device::Vk.Device, queue_family_index, array::Vector{Float32})
  # Provide Vulkan with our shader.
  stage = Vk.ShaderStageFlag(source.info.interface.execution_model)
  @assert stage == Vk.SHADER_STAGE_COMPUTE_BIT
  shader = Vk.ShaderModule(device, source)

  # Construct a buffer on the device.
  buffer = Vk.Buffer(device, sizeof(array), Vk.BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, Vk.SHARING_MODE_EXCLUSIVE, [queue_family_index])
  # Allocate memory for it, selecting a memory that is host-visible and host-coherent.
  memory_requirements = Vk.get_buffer_memory_requirements(device, buffer)
  memory_index = find_memory_type(device.physical_device, memory_requirements.memory_type_bits, Vk.MEMORY_PROPERTY_HOST_VISIBLE_BIT | Vk.MEMORY_PROPERTY_HOST_COHERENT_BIT)
  memory = Vk.DeviceMemory(device, memory_requirements.size, memory_index; next = Vk.MemoryAllocateFlagsInfo(0; flags = Vk.MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT))
  unwrap(Vk.bind_buffer_memory(device, buffer, memory, 0))

  # Get a pointer to this memory, so we can write to it.
  memory_ptr = unwrap(Vk.map_memory(device, memory, 0, sizeof(array)))
  GC.@preserve array begin
    data_ptr = pointer(array)
    unsafe_copyto!(Ptr{Float32}(memory_ptr), data_ptr, length(array))
  end

  # Get its device address while we&#39;re at it.
  # Note that this is a device address, not a host address; it should only be used inside a shader.
  buffer_address = Vk.get_buffer_device_address(device, Vk.BufferDeviceAddressInfo(buffer))

  # Create the compute pipeline our shader will be executed with.
  push_constant_range = Vk.PushConstantRange(stage, 0, 12)
  pipeline_layout = Vk.PipelineLayout(device, [], [push_constant_range])
  # Note: the name of the entry point of any shader compiled with SPIRV.jl will always be &quot;main&quot;.
  pipeline_info = Vk.ComputePipelineCreateInfo(Vk.PipelineShaderStageCreateInfo(stage, shader, &quot;main&quot;), pipeline_layout, 0)
  ((pipeline, _...), _) = unwrap(Vk.create_compute_pipelines(device, [pipeline_info]))

  # Build the command buffer and record the appropriate commands to invoke our compute shader.
  command_pool = Vk.CommandPool(device, queue_family_index)
  (command_buffer, _...) = unwrap(Vk.allocate_command_buffers(device, Vk.CommandBufferAllocateInfo(command_pool, Vk.COMMAND_BUFFER_LEVEL_PRIMARY, 1)))
  Vk.begin_command_buffer(command_buffer, Vk.CommandBufferBeginInfo())
  Vk.cmd_bind_pipeline(command_buffer, Vk.PIPELINE_BIND_POINT_COMPUTE, pipeline)
  # --&gt; This is where we provide our `ComputeData` argument.
  push_constant = serialize(ComputeData(buffer_address, length(array)), source.info.layout)
  push_constant_ptr = pointer(push_constant)
  Vk.cmd_push_constants(command_buffer, pipeline_layout, push_constant_range.stage_flags, push_constant_range.offset, push_constant_range.size, Ptr{Cvoid}(push_constant_ptr))
  # --------------------------------------------------------
  # Dispatch as many workgroups as necessary to cover all array elements.
  workgroup_invocations = prod(source.info.interface.execution_options.local_size)
  Vk.cmd_dispatch(command_buffer, cld(length(array), workgroup_invocations), 1, 1)
  Vk.end_command_buffer(command_buffer)

  # Get a queue for submission, then submit the command buffer.
  queue = Vk.get_device_queue(device, queue_family_index, 0)
  unwrap(Vk.queue_submit(queue, [Vk.SubmitInfo([], [], [command_buffer], [])]))

  # Wait for all operations to finish, making sure none of the
  # required resources are cleaned up by the GC before then.
  # Finally, retrieve the data.
  GC.@preserve array buffer memory pipeline_layout pipeline command_pool command_buffer push_constant queue begin
    unwrap(Vk.queue_wait_idle(queue))
    data_ptr = pointer(array)
    unsafe_copyto!(data_ptr, Ptr{Float32}(memory_ptr), length(array))
    Vk.free_command_buffers(device, command_pool, [command_buffer])
    Vk.unmap_memory(device, memory)
  end
  array
end

# Utility function to find a memory that satisfies all our requirements.
function find_memory_type(physical_device::Vk.PhysicalDevice, type, properties::Vk.MemoryPropertyFlag)
  memory_properties = Vk.get_physical_device_memory_properties(physical_device)
  memory_types = memory_properties.memory_types[1:(memory_properties.memory_type_count)]
  candidate_indices = findall(i -&gt; type &amp; (1 &lt;&lt; i) ≠ 0, 0:(memory_properties.memory_type_count - 1))
  # Make sure we get a host-coherent memory, because we don&#39;t want
  #  to bother with flushing and invalidating memory.
  index = findfirst(i -&gt; in(Vk.MEMORY_PROPERTY_HOST_COHERENT_BIT, memory_types[i].property_flags), candidate_indices)
  index - 1
end

array .= range(0.0, 1.0, length(array))

execute_shader(source, device, queue_family_index, array)</code></pre><p>I&#39;d like to draw attention to something <em>extremely</em> important. This concerns the following piece of code in <code>execute_shader</code>:</p><pre><code class="language-julia hljs">push_constant = serialize(ComputeData(buffer_address, length(data)), source.info.layout)</code></pre><p>One may have thought instead to construct a <code>Ref</code> to the push constant, and then convert the <code>Ref</code> into a pointer. That would actually work, in the case where:</p><ul><li>No mutable data is stored inside (as Julia stores pointers to these objects, not their data, for mutable struct fields).</li><li>Data alignments match exactly with the alignments present in the shader.</li></ul><p>Even if we assume that we do not have mutable data, data alignments may not match.</p><p>Let&#39;s take a look at all that. Using <a href="https://github.com/tecosaur/About.jl">About.jl</a>, we can see the layout of the Julia structure:</p><pre><code class="language- hljs">using About: about

about(ComputeData)</code></pre><p>We have:</p><ul><li>8 bytes for the <code>UInt64</code></li><li>4 bytes for the <code>UInt32</code></li><li>4 extra bytes of padding.</li></ul><p>Totalling a size of 16 bytes.</p><p>The shader we compiled has the following decorations:</p><pre><code class="language- hljs">using SPIRV: SPIRV # hide

amod = SPIRV.annotate(SPIRV.Module(shader.ir)) # hide
display(amod[amod.annotations]); # hide
nothing #hide</code></pre><p>The <code>MemberDecorate(..., ..., Offset, ...)</code> decorations provide offset information for each field of a structure (here, the only structure present in the shader is the one that represents our <code>ComputeData</code>).</p><p>We have:</p><ul><li>An offset of 0 bytes for the <code>UInt64</code> whose size is 8 bytes.</li><li>An offset of 8 bytes for the <code>UInt32</code> whose size is 4 bytes.</li><li>In absence of remaining layout information, we may conclude that the total size equals 12 bytes.</li></ul><p>In this case, the data offsets are identical, therefore memory accesses won&#39;t be problematic. But there are cases (notably with non-default layout parameters) where offsets differ, and it is good to be aware of that. To avoid relying on chance, it is advised to <a href="@ref"><code>serialize</code></a> the data using the appropriate layout.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../creating_a_shader/">« Creating a shader</a><a class="docs-footer-nextpage" href="../../reference/shader_compilation/">Julia → SPIR-V compiler »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 28 July 2024 19:18">Sunday 28 July 2024</span>. Using Julia version 1.12.0-DEV.935.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
