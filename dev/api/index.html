<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API ¬∑ SPIRV.jl</title><meta name="title" content="API ¬∑ SPIRV.jl"/><meta property="og:title" content="API ¬∑ SPIRV.jl"/><meta property="twitter:title" content="API ¬∑ SPIRV.jl"/><meta name="description" content="Documentation for SPIRV.jl."/><meta property="og:description" content="Documentation for SPIRV.jl."/><meta property="twitter:description" content="Documentation for SPIRV.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SPIRV.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SPIRV.jl</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/manipulating_spirv/">Manipulating SPIR-V binaries</a></li><li><a class="tocitem" href="../tutorials/creating_a_shader/">Creating a shader</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/shader_compilation/">Julia ‚Üí SPIR-V compiler</a></li><li><a class="tocitem" href="../reference/bit_width/">Integer and float bit widths</a></li></ul></li><li><a class="tocitem" href="../features/">Features</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/serenity4/SPIRV.jl/blob/main/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><div class="admonition is-warning" id="Warning-82bc92add7f8f766"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-82bc92add7f8f766" title="Permalink"></a></header><div class="admonition-body"><p>This section is incomplete. Readers are kindly encouraged to go through the tests and source code for more information about the API usage.</p></div></div><ul><li><a href="#SPIRV.REGION_BLOCK"><code>SPIRV.REGION_BLOCK</code></a></li><li><a href="#SPIRV.SPIR_TYPE_STRUCT"><code>SPIRV.SPIR_TYPE_STRUCT</code></a></li><li><a href="#SPIRV.œÄF"><code>SPIRV.œÄF</code></a></li><li><a href="#SPIRV.AnnotatedModule"><code>SPIRV.AnnotatedModule</code></a></li><li><a href="#SPIRV.ControlTree"><code>SPIRV.ControlTree</code></a></li><li><a href="#SPIRV.DeltaGraph"><code>SPIRV.DeltaGraph</code></a></li><li><a href="#SPIRV.F"><code>SPIRV.F</code></a></li><li><a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a></li><li><a href="#SPIRV.IR"><code>SPIRV.IR</code></a></li><li><a href="#SPIRV.Image"><code>SPIRV.Image</code></a></li><li><a href="#SPIRV.Instruction"><code>SPIRV.Instruction</code></a></li><li><a href="#SPIRV.LayoutStrategy"><code>SPIRV.LayoutStrategy</code></a></li><li><a href="#SPIRV.Module"><code>SPIRV.Module</code></a></li><li><a href="#SPIRV.NativeLayout"><code>SPIRV.NativeLayout</code></a></li><li><a href="#SPIRV.NoPadding"><code>SPIRV.NoPadding</code></a></li><li><a href="#SPIRV.OpCode"><code>SPIRV.OpCode</code></a></li><li><a href="#SPIRV.PhysicalInstruction"><code>SPIRV.PhysicalInstruction</code></a></li><li><a href="#SPIRV.PhysicalModule"><code>SPIRV.PhysicalModule</code></a></li><li><a href="#SPIRV.ResultID"><code>SPIRV.ResultID</code></a></li><li><a href="#SPIRV.SPIRVTarget"><code>SPIRV.SPIRVTarget</code></a></li><li><a href="#SPIRV.ShaderCompilationCache"><code>SPIRV.ShaderCompilationCache</code></a></li><li><a href="#SPIRV.ShaderLayout"><code>SPIRV.ShaderLayout</code></a></li><li><a href="#SPIRV.ShaderSource"><code>SPIRV.ShaderSource</code></a></li><li><a href="#SPIRV.SupportedFeatures"><code>SPIRV.SupportedFeatures</code></a></li><li><a href="#SPIRV.TypeMetadata"><code>SPIRV.TypeMetadata</code></a></li><li><a href="#SPIRV.U"><code>SPIRV.U</code></a></li><li><a href="#SPIRV.VulkanLayout"><code>SPIRV.VulkanLayout</code></a></li><li><a href="#SPIRV.alignment"><code>SPIRV.alignment</code></a></li><li><a href="#SPIRV.datasize"><code>SPIRV.datasize</code></a></li><li><a href="#SPIRV.disassemble-Tuple{IO, SPIRV.Module}"><code>SPIRV.disassemble</code></a></li><li><a href="#SPIRV.spir_type-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Union{Nothing, TypeMap}}} where T"><code>SPIRV.spir_type</code></a></li><li><a href="#SPIRV.@any_hit-Tuple"><code>SPIRV.@any_hit</code></a></li><li><a href="#SPIRV.@callable-Tuple"><code>SPIRV.@callable</code></a></li><li><a href="#SPIRV.@closest_hit-Tuple"><code>SPIRV.@closest_hit</code></a></li><li><a href="#SPIRV.@compute-Tuple"><code>SPIRV.@compute</code></a></li><li><a href="#SPIRV.@for"><code>SPIRV.@for</code></a></li><li><a href="#SPIRV.@fragment-Tuple"><code>SPIRV.@fragment</code></a></li><li><a href="#SPIRV.@geometry-Tuple"><code>SPIRV.@geometry</code></a></li><li><a href="#SPIRV.@intersection-Tuple"><code>SPIRV.@intersection</code></a></li><li><a href="#SPIRV.@load-Tuple{Any}"><code>SPIRV.@load</code></a></li><li><a href="#SPIRV.@mesh-Tuple"><code>SPIRV.@mesh</code></a></li><li><a href="#SPIRV.@miss-Tuple"><code>SPIRV.@miss</code></a></li><li><a href="#SPIRV.@ray_generation-Tuple"><code>SPIRV.@ray_generation</code></a></li><li><a href="#SPIRV.@store"><code>SPIRV.@store</code></a></li><li><a href="#SPIRV.@task-Tuple"><code>SPIRV.@task</code></a></li><li><a href="#SPIRV.@tessellation_control-Tuple"><code>SPIRV.@tessellation_control</code></a></li><li><a href="#SPIRV.@tessellation_evaluation-Tuple"><code>SPIRV.@tessellation_evaluation</code></a></li><li><a href="#SPIRV.@vertex-Tuple"><code>SPIRV.@vertex</code></a></li></ul><article><details class="docstring" open="true"><summary id="SPIRV.SPIR_TYPE_STRUCT"><a class="docstring-binding" href="#SPIRV.SPIR_TYPE_STRUCT"><code>SPIRV.SPIR_TYPE_STRUCT</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>SPIR-V aggregate type.</p><p>Equality is defined in terms of identity, since different aggregate types have in principle different semantics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/spir_types.jl#LL18-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.œÄF"><a class="docstring-binding" href="#SPIRV.œÄF"><code>SPIRV.œÄF</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>32-bit floating-point representation of <code>œÄ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/SPIRV.jl#LL77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.AnnotatedModule"><a class="docstring-binding" href="#SPIRV.AnnotatedModule"><code>SPIRV.AnnotatedModule</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Module annotated with instruction ranges for each logical SPIR-V section, suitable for read-only operations and analyses.</p><p>Any desired modifications of annotated modules should be staged and applied via a <a href="@ref"><code>Diff</code></a>.</p><div class="admonition is-warning" id="Warning-92c7684cb9bf794e"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-92c7684cb9bf794e" title="Permalink"></a></header><div class="admonition-body"><p>This module <em>should not</em> be modified, and in particular <em>must not</em> have its structure affected in any way by the insertion or removal of instructions. Modifications can cause the annotations to become out of sync with the updated state of the module, yielding undefined behavior.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/annotated_module.jl#LL36-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.ControlTree"><a class="docstring-binding" href="#SPIRV.ControlTree"><code>SPIRV.ControlTree</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Control tree.</p><p>The leaves are labeled as <a href="#SPIRV.REGION_BLOCK"><code>REGION_BLOCK</code></a> regions, with the distinguishing property that they have no children.</p><p>Children nodes of any given subtree are in reverse postorder according to the original control-flow graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/analysis/structural_analysis.jl#LL283-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.DeltaGraph"><a class="docstring-binding" href="#SPIRV.DeltaGraph"><code>SPIRV.DeltaGraph</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Graph whose vertices and edges remain identical after deletion of other vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/analysis/deltagraph.jl#LL1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.F"><a class="docstring-binding" href="#SPIRV.F"><code>SPIRV.F</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">x*F
(x)F</code></pre><p>Converts an input <code>x</code> to a <code>Float32</code> when <code>F</code> is right-multiplied with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/SPIRV.jl#LL70-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.FeatureSupport"><a class="docstring-binding" href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Abstract type expressing SPIR-V which capabilities and extensions are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/requirements.jl#LL6-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.IR"><a class="docstring-binding" href="#SPIRV.IR"><code>SPIRV.IR</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Intermediate representation of SPIR-V modules.</p><p>The <code>types</code> and <code>constants</code> mappings can be updated at any time without explicitly notifying of the mutation behavior (i.e. functions may not end with <code>!</code>), so long as additions only are performed. Such additions are currently done upon construction of <code>GlobalsInfo</code>. The ID counter can also be incremented without notice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/ir.jl#LL1-L8">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.Image"><a class="docstring-binding" href="#SPIRV.Image"><code>SPIRV.Image</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>SPIR-V image type.</p><p>Type parameters:</p><ul><li><code>Format</code>: SPIR-V <code>ImageFormat</code> enumerated value.</li><li><code>Dim</code>: SPIR-V <code>Dim</code> enumerated value.</li><li><code>Depth</code>: 64-bit integer with value 0 (not a depth image), 1 (depth image) or 2 (unknown).</li><li><code>Arrayed</code>: <code>Bool</code> indicating whether the image is a layer of an image array.</li><li><code>MS</code>: <code>Bool</code> indicating whether the image is multisampled.</li><li><code>Sampled</code>: 64-bit integer with value 0 (unknown), 1 (may be sampled) or 2 (read-write, no sampling).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/types/image.jl#LL1-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.Instruction"><a class="docstring-binding" href="#SPIRV.Instruction"><code>SPIRV.Instruction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Parsed SPIR-V instruction. It represents an instruction of the form <code>%result_id = %opcode(%arguments...)::%type_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/instructions.jl#LL22-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.LayoutStrategy"><a class="docstring-binding" href="#SPIRV.LayoutStrategy"><code>SPIRV.LayoutStrategy</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Layout strategy used to compute alignments, offsets and strides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.NativeLayout"><a class="docstring-binding" href="#SPIRV.NativeLayout"><code>SPIRV.NativeLayout</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>&quot; Julia layout, with a special handling of mutable fields for composite types.</p><p>Mutable fields are stored as 8-byte pointers in Julia, but in SPIR-V there is no such concept of pointer. Therefore, we treat mutable fields as if they were fully inlined - that imposes a few restrictions on the behavior of such mutable objects, but is necessary to keep some form of compatibility with GPU representations. The alternative would be to completely disallow structs which contain mutable fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL67-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.NoPadding"><a class="docstring-binding" href="#SPIRV.NoPadding"><code>SPIRV.NoPadding</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Layout strategy which assumes no padding is required at all. This might be useful for maximally packing data when serialized, reducing size; or to improve performance by avoiding padding when not needed, e.g. if you already pad your structures manually upfront (only do that if you know what you&#39;re doing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.PhysicalInstruction"><a class="docstring-binding" href="#SPIRV.PhysicalInstruction"><code>SPIRV.PhysicalInstruction</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>SPIR-V instruction in binary format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/instructions.jl#LL11-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.PhysicalModule"><a class="docstring-binding" href="#SPIRV.PhysicalModule"><code>SPIRV.PhysicalModule</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>SPIR-V module, as a series of headers followed by a stream of instructions. The header embeds two magic numbers, one for the module itself and one for the tool that generated it (e.g. <a href="https://github.com/KhronosGroup/glslang">glslang</a>). It also contains the version of the specification applicable to the module, the maximum ID number and an optional instruction schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/parse.jl#LL52-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.ResultID"><a class="docstring-binding" href="#SPIRV.ResultID"><code>SPIRV.ResultID</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Result ID used in a SPIR-V context, following single static assignment rules for valid modules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/result.jl#LL1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.SPIRVTarget"><a class="docstring-binding" href="#SPIRV.SPIRVTarget"><code>SPIRV.SPIRVTarget</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>SPIR-V target for compilation through the Julia frontend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/target.jl#LL3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.ShaderCompilationCache"><a class="docstring-binding" href="#SPIRV.ShaderCompilationCache"><code>SPIRV.ShaderCompilationCache</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ShaderCompilationCache()</code></pre><p>Create a cache that may be used to associate shaders to be compiled (<a href="@ref"><code>ShaderInfo</code></a>) with compiled code (<a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>).</p><p>Although this cache will already significantly speed up shader creation by compiling only what is required, performance-critical applications will additionally want to use a high-level cache that maps a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a> to a driver-dependent object generated by the graphics API chosen for that application. For Vulkan, that would be a <code>Vk.ShaderModule</code>, for example. It is then recommended to use an <code>IdDict</code> to perform the caching, to avoid hashing the whole source code.</p><div class="admonition is-warning" id="Warning-7ef5041ef02f443"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-7ef5041ef02f443" title="Permalink"></a></header><div class="admonition-body"><p>Caching assumes the same <a href="@ref"><code>SPIRVInterpreter</code></a> to be used, and will not look into the <code>ShaderSource</code>&#39;s <code>interp</code> field. Generally, applications should use a single interpreter, and not fiddle with parameters across different shader compilation runs. This allows caching to skip hashing <code>SPIRVInterpreter</code> contents needlessly in what should be &gt;99.9% of cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/cache.jl#LL46-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.ShaderLayout"><a class="docstring-binding" href="#SPIRV.ShaderLayout"><code>SPIRV.ShaderLayout</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Shader-compatible layout strategy, where layout information is strictly read from shader decorations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL486-L488">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.ShaderSource"><a class="docstring-binding" href="#SPIRV.ShaderSource"><code>SPIRV.ShaderSource</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>SPIR-V shader code, with stage and entry point information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/source.jl#LL22-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.SupportedFeatures"><a class="docstring-binding" href="#SPIRV.SupportedFeatures"><code>SPIRV.SupportedFeatures</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Extensions and capabilities supported by a client API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/requirements.jl#LL11-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.TypeMetadata"><a class="docstring-binding" href="#SPIRV.TypeMetadata"><code>SPIRV.TypeMetadata</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Type metadata meant to be analyzed and modified to generate appropriate decorations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL398-L400">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.U"><a class="docstring-binding" href="#SPIRV.U"><code>SPIRV.U</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">x*U
(x)U</code></pre><p>Converts an input <code>x</code> to an <code>UInt32</code> when <code>U</code> is right-multiplied with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/SPIRV.jl#LL63-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.VulkanLayout"><a class="docstring-binding" href="#SPIRV.VulkanLayout"><code>SPIRV.VulkanLayout</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Vulkan-compatible layout strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL210-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.alignment"><a class="docstring-binding" href="#SPIRV.alignment"><code>SPIRV.alignment</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">alignment(layout, T)</code></pre><p>Memory alignment which must be respected when allocating a value of the given type.</p><p>This refers to an <em>external</em> alignment, i.e. this value is of interest when allocating a value of type <code>T</code> within a struct or array. In particular, this value <em>does not</em> indicate what should be the alignment of any struct member or the stride of any array element contained in <code>T</code>, if <code>T</code> is a struct or an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL6-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.datasize"><a class="docstring-binding" href="#SPIRV.datasize"><code>SPIRV.datasize</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">datasize(layout, T)</code></pre><p>This is the total space occupied by a value of type <code>T</code>, including padding between struct elements and array strides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/layouts.jl#LL32-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.disassemble-Tuple{IO, SPIRV.Module}"><a class="docstring-binding" href="#SPIRV.disassemble-Tuple{IO, SPIRV.Module}"><code>SPIRV.disassemble</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">disassemble(io, spir_module)</code></pre><p>Transform the content of <code>spir_module</code> into a human-readable format and prints it to <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/disassemble.jl#LL82-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.spir_type-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Union{Nothing, TypeMap}}} where T"><a class="docstring-binding" href="#SPIRV.spir_type-Union{Tuple{Type{T}}, Tuple{T}, Tuple{Type{T}, Union{Nothing, TypeMap}}} where T"><code>SPIRV.spir_type</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><p>Get a SPIR-V type from a Julia type, caching the mapping in the <code>IR</code> if one is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/spir_types.jl#LL408-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@any_hit-Tuple"><a class="docstring-binding" href="#SPIRV.@any_hit-Tuple"><code>SPIRV.@any_hit</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@any_hit [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a any_hit shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing any_hit-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL70-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@callable-Tuple"><a class="docstring-binding" href="#SPIRV.@callable-Tuple"><code>SPIRV.@callable</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@callable [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a callable shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing callable-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL80-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@closest_hit-Tuple"><a class="docstring-binding" href="#SPIRV.@closest_hit-Tuple"><code>SPIRV.@closest_hit</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@closest_hit [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a closest_hit shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing closest_hit-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL65-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@compute-Tuple"><a class="docstring-binding" href="#SPIRV.@compute-Tuple"><code>SPIRV.@compute</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@compute [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a compute shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = ComputeExecutionOptions()</code>: a <a href="@ref"><code>ComputeExecutionOptions</code></a> structure providing compute-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL50-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@for"><a class="docstring-binding" href="#SPIRV.@for"><code>SPIRV.@for</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><p>@for i in iter begin #= ... do something with i ... =# end   @for i in iter1, j in iter2 begin #= ... do something with i and j ... =# end</p><p>Define a C-style <code>for</code> loop.</p><p>This loop does not rely on the standard iteration protocol in Julia, and will instead mimic how loops work in C: a loop entry point usually defines loop variables, a condition guards the loop body, and a continue block usually increments loop variables on subsequent iterations.</p><p><code>iter</code> must implement <a href="@ref"><code>pre_loop</code></a>, <a href="@ref"><code>cond_loop</code></a> and <a href="@ref"><code>post_loop</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/utility.jl#LL85-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@fragment-Tuple"><a class="docstring-binding" href="#SPIRV.@fragment-Tuple"><code>SPIRV.@fragment</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@fragment [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a fragment shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = FragmentExecutionOptions()</code>: a <a href="@ref"><code>FragmentExecutionOptions</code></a> structure providing fragment-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL45-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@geometry-Tuple"><a class="docstring-binding" href="#SPIRV.@geometry-Tuple"><code>SPIRV.@geometry</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@geometry [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a geometry shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = GeometryExecutionOptions()</code>: a <a href="@ref"><code>GeometryExecutionOptions</code></a> structure providing geometry-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL30-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@intersection-Tuple"><a class="docstring-binding" href="#SPIRV.@intersection-Tuple"><code>SPIRV.@intersection</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@intersection [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a intersection shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing intersection-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL60-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@load-Tuple{Any}"><a class="docstring-binding" href="#SPIRV.@load-Tuple{Any}"><code>SPIRV.@load</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@load address::T
@load address[index]::T</code></pre><p>Load a value of type <code>T</code>, either directly (if no index is specified) or at <code>offset = index - 1</code> elements from <code>address</code>. <code>address</code> should be a device address, i.e. a <code>UInt64</code> value representing the address of a physical storage buffer.</p><div class="admonition is-info" id="Note-51f0645948c41299"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-51f0645948c41299" title="Permalink"></a></header><div class="admonition-body"><p>Although <code>@load address::T</code> and <code>@load address[1]::T</code> look semantically the same, you should use whichever is appropriate given the underlying data; if you have an array pointer, use the latter, and if you have a pointer to a single element, use the former. Otherwise, executing this on the CPU will most likely crash if attempted with a <code>T</code> that is a mutable type, because mutable elements are stored as object pointers in arrays, requiring an extra bit of indirection that is expressed by <code>@load address[1]::T</code> if one wants to get the correct address.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/types/pointer.jl#LL114-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@mesh-Tuple"><a class="docstring-binding" href="#SPIRV.@mesh-Tuple"><code>SPIRV.@mesh</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@mesh [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a mesh shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = MeshExecutionOptions()</code>: a <a href="@ref"><code>MeshExecutionOptions</code></a> structure providing mesh-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL90-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@miss-Tuple"><a class="docstring-binding" href="#SPIRV.@miss-Tuple"><code>SPIRV.@miss</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@miss [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a miss shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing miss-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL75-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@ray_generation-Tuple"><a class="docstring-binding" href="#SPIRV.@ray_generation-Tuple"><code>SPIRV.@ray_generation</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@ray_generation [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a ray_generation shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing ray_generation-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL55-L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@store"><a class="docstring-binding" href="#SPIRV.@store"><code>SPIRV.@store</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@store value address::T
@store value address[index]::T
@store address::T = value
@store address[index]::T = value</code></pre><p>Store a value of type <code>T</code> at the given <code>address</code>, either directly (if no index is specified) or at an offset of <code>index - 1</code> elements from <code>address</code>.</p><p>If <code>value</code> is not of type <code>T</code>, a conversion will be attempted.</p><p><code>address</code> should be a device address, i.e. a <code>UInt64</code> value representing the address of a physical storage buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/types/pointer.jl#LL147-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@task-Tuple"><a class="docstring-binding" href="#SPIRV.@task-Tuple"><code>SPIRV.@task</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@task [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a task shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing task-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL85-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@tessellation_control-Tuple"><a class="docstring-binding" href="#SPIRV.@tessellation_control-Tuple"><code>SPIRV.@tessellation_control</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@tessellation_control [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a tessellation_control shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = TessellationExecutionOptions()</code>: a <a href="@ref"><code>TessellationExecutionOptions</code></a> structure providing tessellation_control-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL35-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@tessellation_evaluation-Tuple"><a class="docstring-binding" href="#SPIRV.@tessellation_evaluation-Tuple"><code>SPIRV.@tessellation_evaluation</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@tessellation_evaluation [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a tessellation_evaluation shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = TessellationExecutionOptions()</code>: a <a href="@ref"><code>TessellationExecutionOptions</code></a> structure providing tessellation_evaluation-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL40-L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.@vertex-Tuple"><a class="docstring-binding" href="#SPIRV.@vertex-Tuple"><code>SPIRV.@vertex</code></a> ‚Äî <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@vertex [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a vertex shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing vertex-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/frontend/shader/api.jl#LL25-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.Module"><a class="docstring-binding" href="#SPIRV.Module"><code>SPIRV.Module</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Logical representation of a SPIR-V module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/parse.jl#LL253-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.REGION_BLOCK"><a class="docstring-binding" href="#SPIRV.REGION_BLOCK"><code>SPIRV.REGION_BLOCK</code></a> ‚Äî <span class="docstring-category">Constant</span></summary><section><div><p>Sequence of blocks <code>u</code> ‚îÄ‚Üí [<code>v</code>, <code>vs...</code>] ‚îÄ‚Üí <code>w</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/analysis/structural_analysis.jl#LL17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="SPIRV.OpCode"><a class="docstring-binding" href="#SPIRV.OpCode"><code>SPIRV.OpCode</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><p>Enumerated value representing the type of an instruction. See https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#<em>instructions</em>3 for a list of SPIR-V opcodes (excluding extended instruction sets).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/86b06138e4d36d7956bfbe087be10a5e130da132/src/SPIRV.jl#LL91-L94">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../features/">¬´ Features</a><a class="docs-footer-nextpage" href="../devdocs/">Developer documentation ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 31 January 2026 21:29">Saturday 31 January 2026</span>. Using Julia version 1.11.8.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
