<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SPIRV.jl</title><meta name="title" content="API · SPIRV.jl"/><meta property="og:title" content="API · SPIRV.jl"/><meta property="twitter:title" content="API · SPIRV.jl"/><meta name="description" content="Documentation for SPIRV.jl."/><meta property="og:description" content="Documentation for SPIRV.jl."/><meta property="twitter:description" content="Documentation for SPIRV.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SPIRV.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SPIRV.jl</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/manipulating_spirv/">Manipulating SPIR-V binaries</a></li><li><a class="tocitem" href="../tutorials/creating_a_shader/">Creating a shader</a></li><li><a class="tocitem" href="../tutorials/executing_a_shader/">Executing a shader</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../reference/shader_compilation/">Julia → SPIR-V compiler</a></li><li><a class="tocitem" href="../reference/bit_width/">Integer and float bit widths</a></li></ul></li><li><a class="tocitem" href="../features/">Features</a></li><li class="is-active"><a class="tocitem" href>API</a></li><li><a class="tocitem" href="../devdocs/">Developer documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/serenity4/SPIRV.jl/blob/main/docs/src/api.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This section is incomplete. Readers are kindly encouraged to go through the tests and source code for more information about the API usage.</p></div></div><ul><li><a href="#SPIRV.REGION_BLOCK"><code>SPIRV.REGION_BLOCK</code></a></li><li><a href="#SPIRV.πF"><code>SPIRV.πF</code></a></li><li><a href="#SPIRV.AnnotatedModule"><code>SPIRV.AnnotatedModule</code></a></li><li><a href="#SPIRV.ControlTree"><code>SPIRV.ControlTree</code></a></li><li><a href="#SPIRV.DeltaGraph"><code>SPIRV.DeltaGraph</code></a></li><li><a href="#SPIRV.F"><code>SPIRV.F</code></a></li><li><a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a></li><li><a href="#SPIRV.IR"><code>SPIRV.IR</code></a></li><li><a href="#SPIRV.Image"><code>SPIRV.Image</code></a></li><li><a href="#SPIRV.Instruction"><code>SPIRV.Instruction</code></a></li><li><a href="#SPIRV.LayoutStrategy"><code>SPIRV.LayoutStrategy</code></a></li><li><a href="#SPIRV.Module"><code>SPIRV.Module</code></a></li><li><a href="#SPIRV.NativeLayout"><code>SPIRV.NativeLayout</code></a></li><li><a href="#SPIRV.NoPadding"><code>SPIRV.NoPadding</code></a></li><li><a href="#SPIRV.OpCode"><code>SPIRV.OpCode</code></a></li><li><a href="#SPIRV.PhysicalInstruction"><code>SPIRV.PhysicalInstruction</code></a></li><li><a href="#SPIRV.PhysicalModule"><code>SPIRV.PhysicalModule</code></a></li><li><a href="#SPIRV.ResultID"><code>SPIRV.ResultID</code></a></li><li><a href="#SPIRV.SPIRVTarget"><code>SPIRV.SPIRVTarget</code></a></li><li><a href="#SPIRV.ShaderCompilationCache"><code>SPIRV.ShaderCompilationCache</code></a></li><li><a href="#SPIRV.ShaderLayout"><code>SPIRV.ShaderLayout</code></a></li><li><a href="#SPIRV.ShaderSource"><code>SPIRV.ShaderSource</code></a></li><li><a href="#SPIRV.StructType"><code>SPIRV.StructType</code></a></li><li><a href="#SPIRV.SupportedFeatures"><code>SPIRV.SupportedFeatures</code></a></li><li><a href="#SPIRV.TypeMetadata"><code>SPIRV.TypeMetadata</code></a></li><li><a href="#SPIRV.U"><code>SPIRV.U</code></a></li><li><a href="#SPIRV.VulkanLayout"><code>SPIRV.VulkanLayout</code></a></li><li><a href="#SPIRV.alignment"><code>SPIRV.alignment</code></a></li><li><a href="#SPIRV.datasize"><code>SPIRV.datasize</code></a></li><li><a href="#SPIRV.disassemble-Tuple{IO, SPIRV.Module}"><code>SPIRV.disassemble</code></a></li><li><a href="#SPIRV.spir_type"><code>SPIRV.spir_type</code></a></li><li><a href="#SPIRV.@any_hit-Tuple"><code>SPIRV.@any_hit</code></a></li><li><a href="#SPIRV.@callable-Tuple"><code>SPIRV.@callable</code></a></li><li><a href="#SPIRV.@closest_hit-Tuple"><code>SPIRV.@closest_hit</code></a></li><li><a href="#SPIRV.@compute-Tuple"><code>SPIRV.@compute</code></a></li><li><a href="#SPIRV.@fragment-Tuple"><code>SPIRV.@fragment</code></a></li><li><a href="#SPIRV.@geometry-Tuple"><code>SPIRV.@geometry</code></a></li><li><a href="#SPIRV.@intersection-Tuple"><code>SPIRV.@intersection</code></a></li><li><a href="#SPIRV.@load-Tuple{Any}"><code>SPIRV.@load</code></a></li><li><a href="#SPIRV.@mesh-Tuple"><code>SPIRV.@mesh</code></a></li><li><a href="#SPIRV.@miss-Tuple"><code>SPIRV.@miss</code></a></li><li><a href="#SPIRV.@ray_generation-Tuple"><code>SPIRV.@ray_generation</code></a></li><li><a href="#SPIRV.@store"><code>SPIRV.@store</code></a></li><li><a href="#SPIRV.@task-Tuple"><code>SPIRV.@task</code></a></li><li><a href="#SPIRV.@tessellation_control-Tuple"><code>SPIRV.@tessellation_control</code></a></li><li><a href="#SPIRV.@tessellation_evaluation-Tuple"><code>SPIRV.@tessellation_evaluation</code></a></li><li><a href="#SPIRV.@vertex-Tuple"><code>SPIRV.@vertex</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.πF" href="#SPIRV.πF"><code>SPIRV.πF</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>32-bit floating-point representation of <code>π</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/SPIRV.jl#LL76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.AnnotatedModule" href="#SPIRV.AnnotatedModule"><code>SPIRV.AnnotatedModule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Module annotated with instruction ranges for each logical SPIR-V section, suitable for read-only operations and analyses.</p><p>Any desired modifications of annotated modules should be staged and applied via a <a href="@ref"><code>Diff</code></a>.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>This module <em>should not</em> be modified, and in particular <em>must not</em> have its structure affected in any way by the insertion or removal of instructions. Modifications can cause the annotations to become out of sync with the updated state of the module, yielding undefined behavior.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/annotated_module.jl#LL36-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.ControlTree" href="#SPIRV.ControlTree"><code>SPIRV.ControlTree</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Control tree.</p><p>The leaves are labeled as <a href="#SPIRV.REGION_BLOCK"><code>REGION_BLOCK</code></a> regions, with the distinguishing property that they have no children.</p><p>Children nodes of any given subtree are in reverse postorder according to the original control-flow graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/analysis/structural_analysis.jl#LL267-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.DeltaGraph" href="#SPIRV.DeltaGraph"><code>SPIRV.DeltaGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Graph whose vertices and edges remain identical after deletion of other vertices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/analysis/deltagraph.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.F" href="#SPIRV.F"><code>SPIRV.F</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">x*F
(x)F</code></pre><p>Converts an input <code>x</code> to a <code>Float32</code> when <code>F</code> is right-multiplied with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/SPIRV.jl#LL69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.FeatureSupport" href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type expressing SPIR-V which capabilities and extensions are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/requirements.jl#LL6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.IR" href="#SPIRV.IR"><code>SPIRV.IR</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Intermediate representation of SPIR-V modules.</p><p>The <code>types</code> and <code>constants</code> mappings can be updated at any time without explicitly notifying of the mutation behavior (i.e. functions may not end with <code>!</code>), so long as additions only are performed. Such additions are currently done upon construction of <code>GlobalsInfo</code>. The ID counter can also be incremented without notice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/ir.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.Image" href="#SPIRV.Image"><code>SPIRV.Image</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V image type.</p><p>Type parameters:</p><ul><li><code>Format</code>: SPIR-V <code>ImageFormat</code> enumerated value.</li><li><code>Dim</code>: SPIR-V <code>Dim</code> enumerated value.</li><li><code>Depth</code>: 64-bit integer with value 0 (not a depth image), 1 (depth image) or 2 (unknown).</li><li><code>Arrayed</code>: <code>Bool</code> indicating whether the image is a layer of an image array.</li><li><code>MS</code>: <code>Bool</code> indicating whether the image is multisampled.</li><li><code>Sampled</code>: 64-bit integer with value 0 (unknown), 1 (may be sampled) or 2 (read-write, no sampling).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/types/image.jl#LL1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.Instruction" href="#SPIRV.Instruction"><code>SPIRV.Instruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Parsed SPIR-V instruction. It represents an instruction of the form <code>%result_id = %opcode(%arguments...)::%type_id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/instructions.jl#LL22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.LayoutStrategy" href="#SPIRV.LayoutStrategy"><code>SPIRV.LayoutStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Layout strategy used to compute alignments, offsets and strides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.NativeLayout" href="#SPIRV.NativeLayout"><code>SPIRV.NativeLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><p>&quot; Julia layout, with a special handling of mutable fields for composite types.</p><p>Mutable fields are stored as 8-byte pointers in Julia, but in SPIR-V there is no such concept of pointer. Therefore, we treat mutable fields as if they were fully inlined - that imposes a few restrictions on the behavior of such mutable objects, but is necessary to keep some form of compatibility with GPU representations. The alternative would be to completely disallow structs which contain mutable fields.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.NoPadding" href="#SPIRV.NoPadding"><code>SPIRV.NoPadding</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Layout strategy which assumes no padding is required at all. This might be useful for maximally packing data when serialized, reducing size; or to improve performance by avoiding padding when not needed, e.g. if you already pad your structures manually upfront (only do that if you know what you&#39;re doing).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL96-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.PhysicalInstruction" href="#SPIRV.PhysicalInstruction"><code>SPIRV.PhysicalInstruction</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V instruction in binary format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/instructions.jl#LL11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.PhysicalModule" href="#SPIRV.PhysicalModule"><code>SPIRV.PhysicalModule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V module, as a series of headers followed by a stream of instructions. The header embeds two magic numbers, one for the module itself and one for the tool that generated it (e.g. <a href="https://github.com/KhronosGroup/glslang">glslang</a>). It also contains the version of the specification applicable to the module, the maximum ID number and an optional instruction schema.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/parse.jl#LL54-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.ResultID" href="#SPIRV.ResultID"><code>SPIRV.ResultID</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Result ID used in a SPIR-V context, following single static assignment rules for valid modules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/result.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.SPIRVTarget" href="#SPIRV.SPIRVTarget"><code>SPIRV.SPIRVTarget</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V target for compilation through the Julia frontend.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/target.jl#LL3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.ShaderCompilationCache" href="#SPIRV.ShaderCompilationCache"><code>SPIRV.ShaderCompilationCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShaderCompilationCache()</code></pre><p>Create a cache that may be used to associate shaders to be compiled (<a href="@ref"><code>ShaderInfo</code></a>) with compiled code (<a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>).</p><p>Although this cache will already significantly speed up shader creation by compiling only what is required, performance-critical applications will additionally want to use a high-level cache that maps a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a> to a driver-dependent object generated by the graphics API chosen for that application. For Vulkan, that would be a <code>Vk.ShaderModule</code>, for example. It is then recommended to use an <code>IdDict</code> to perform the caching, to avoid hashing the whole source code.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Caching assumes the same <a href="@ref"><code>SPIRVInterpreter</code></a> to be used, and will not look into the <code>ShaderSource</code>&#39;s <code>interp</code> field. Generally, applications should use a single interpreter, and not fiddle with parameters across different shader compilation runs. This allows caching to skip hashing <code>SPIRVInterpreter</code> contents needlessly in what should be &gt;99.9% of cases.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/cache.jl#LL46-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.ShaderLayout" href="#SPIRV.ShaderLayout"><code>SPIRV.ShaderLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Shader-compatible layout strategy, where layout information is strictly read from shader decorations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL351-L353">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.ShaderSource" href="#SPIRV.ShaderSource"><code>SPIRV.ShaderSource</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V shader code, with stage and entry point information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/source.jl#LL22-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.StructType" href="#SPIRV.StructType"><code>SPIRV.StructType</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SPIR-V aggregate type.</p><p>Equality is defined in terms of identity, since different aggregate types have in principle different semantics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/spir_types.jl#LL107-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.SupportedFeatures" href="#SPIRV.SupportedFeatures"><code>SPIRV.SupportedFeatures</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Extensions and capabilities supported by a client API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/requirements.jl#LL11-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.TypeMetadata" href="#SPIRV.TypeMetadata"><code>SPIRV.TypeMetadata</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type metadata meant to be analyzed and modified to generate appropriate decorations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL272-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.U" href="#SPIRV.U"><code>SPIRV.U</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">x*U
(x)U</code></pre><p>Converts an input <code>x</code> to an <code>UInt32</code> when <code>U</code> is right-multiplied with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/SPIRV.jl#LL62-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.VulkanLayout" href="#SPIRV.VulkanLayout"><code>SPIRV.VulkanLayout</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Vulkan-compatible layout strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL195-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.alignment" href="#SPIRV.alignment"><code>SPIRV.alignment</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">alignment(layout, T)</code></pre><p>Memory alignment which must be respected when allocating a value of the given type.</p><p>This refers to an <em>external</em> alignment, i.e. this value is of interest when allocating a value of type <code>T</code> within a struct or array. In particular, this value <em>does not</em> indicate what should be the alignment of any struct member or the stride of any array element contained in <code>T</code>, if <code>T</code> is a struct or an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.datasize" href="#SPIRV.datasize"><code>SPIRV.datasize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">datasize(layout, T)</code></pre><p>This is the total space occupied by a value of type <code>T</code>, including padding between struct elements and array strides.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/layouts.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.disassemble-Tuple{IO, SPIRV.Module}" href="#SPIRV.disassemble-Tuple{IO, SPIRV.Module}"><code>SPIRV.disassemble</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disassemble(io, spir_module)</code></pre><p>Transform the content of <code>spir_module</code> into a human-readable format and prints it to <code>io</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/disassemble.jl#LL82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.spir_type" href="#SPIRV.spir_type"><code>SPIRV.spir_type</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Get a SPIR-V type from a Julia type, caching the mapping in the <code>IR</code> if one is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/spir_types.jl#LL224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@any_hit-Tuple" href="#SPIRV.@any_hit-Tuple"><code>SPIRV.@any_hit</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@any_hit [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a any_hit shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing any_hit-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL70-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@callable-Tuple" href="#SPIRV.@callable-Tuple"><code>SPIRV.@callable</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@callable [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a callable shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing callable-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL80-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@closest_hit-Tuple" href="#SPIRV.@closest_hit-Tuple"><code>SPIRV.@closest_hit</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@closest_hit [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a closest_hit shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing closest_hit-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL65-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@compute-Tuple" href="#SPIRV.@compute-Tuple"><code>SPIRV.@compute</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@compute [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a compute shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = ComputeExecutionOptions()</code>: a <a href="@ref"><code>ComputeExecutionOptions</code></a> structure providing compute-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL50-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@fragment-Tuple" href="#SPIRV.@fragment-Tuple"><code>SPIRV.@fragment</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@fragment [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a fragment shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = FragmentExecutionOptions()</code>: a <a href="@ref"><code>FragmentExecutionOptions</code></a> structure providing fragment-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL45-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@geometry-Tuple" href="#SPIRV.@geometry-Tuple"><code>SPIRV.@geometry</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@geometry [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a geometry shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = GeometryExecutionOptions()</code>: a <a href="@ref"><code>GeometryExecutionOptions</code></a> structure providing geometry-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL30-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@intersection-Tuple" href="#SPIRV.@intersection-Tuple"><code>SPIRV.@intersection</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@intersection [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a intersection shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing intersection-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL60-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@load-Tuple{Any}" href="#SPIRV.@load-Tuple{Any}"><code>SPIRV.@load</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@load address::T
@load address[index]::T</code></pre><p>Load a value of type <code>T</code>, either directly (if no index is specified) or at <code>offset = index - 1</code> elements from <code>address</code>. <code>address</code> should be a device address, i.e. a <code>UInt64</code> value representing the address of a physical storage buffer.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Although <code>@load address::T</code> and <code>@load address[1]::T</code> look semantically the same, you should use whichever is appropriate given the underlying data; if you have an array pointer, use the latter, and if you have a pointer to a single element, use the former. Otherwise, executing this on the CPU will most likely crash if attempted with a <code>T</code> that is a mutable type, because mutable elements are stored as object pointers in arrays, requiring an extra bit of indirection that is expressed by <code>@load address[1]::T</code> if one wants to get the correct address.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/types/pointer.jl#LL114-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@mesh-Tuple" href="#SPIRV.@mesh-Tuple"><code>SPIRV.@mesh</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mesh [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a mesh shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = MeshExecutionOptions()</code>: a <a href="@ref"><code>MeshExecutionOptions</code></a> structure providing mesh-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL90-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@miss-Tuple" href="#SPIRV.@miss-Tuple"><code>SPIRV.@miss</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@miss [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a miss shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing miss-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL75-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@ray_generation-Tuple" href="#SPIRV.@ray_generation-Tuple"><code>SPIRV.@ray_generation</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@ray_generation [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a ray_generation shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing ray_generation-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL55-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@store" href="#SPIRV.@store"><code>SPIRV.@store</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@store value address::T
@store value address[index]::T
@store address::T = value
@store address[index]::T = value</code></pre><p>Store a value of type <code>T</code> at the given <code>address</code>, either directly (if no index is specified) or at an offset of <code>index - 1</code> elements from <code>address</code>.</p><p>If <code>value</code> is not of type <code>T</code>, a conversion will be attempted.</p><p><code>address</code> should be a device address, i.e. a <code>UInt64</code> value representing the address of a physical storage buffer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/types/pointer.jl#LL147-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@task-Tuple" href="#SPIRV.@task-Tuple"><code>SPIRV.@task</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@task [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a task shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing task-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL85-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@tessellation_control-Tuple" href="#SPIRV.@tessellation_control-Tuple"><code>SPIRV.@tessellation_control</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tessellation_control [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a tessellation_control shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = TessellationExecutionOptions()</code>: a <a href="@ref"><code>TessellationExecutionOptions</code></a> structure providing tessellation_control-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL35-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@tessellation_evaluation-Tuple" href="#SPIRV.@tessellation_evaluation-Tuple"><code>SPIRV.@tessellation_evaluation</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@tessellation_evaluation [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a tessellation_evaluation shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = TessellationExecutionOptions()</code>: a <a href="@ref"><code>TessellationExecutionOptions</code></a> structure providing tessellation_evaluation-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@vertex-Tuple"><code>@vertex</code></a>, <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL40-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.@vertex-Tuple" href="#SPIRV.@vertex-Tuple"><code>SPIRV.@vertex</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@vertex [parameters] f(::Type1::StorageClass1[{...}], ...)</code></pre><p>Compile the provided signature <code>f(args...)</code> into a vertex shader.</p><p>The supported parameters are the following:</p><ul><li><code>options = CommonExecutionOptions()</code>: a <a href="@ref"><code>CommonExecutionOptions</code></a> structure providing vertex-specific options.</li><li><code>features = AllSupported()</code>: a <a href="#SPIRV.FeatureSupport"><code>SPIRV.FeatureSupport</code></a> structure informing the SPIR-V compiler</li></ul><p>what capabilities and extensions are allowed. In application code, this should generally be a <a href="#SPIRV.SupportedFeatures"><code>SupportedFeatures</code></a> structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides <code>SupportedFeatures(physical_device, api_version, device_extensions, device_features)</code>.</p><ul><li><code>layout = VulkanLayout()</code>: a <a href="#SPIRV.VulkanLayout"><code>VulkanLayout</code></a> to use to compute alignments, strides and offsets in structures and arrays.</li><li><code>cache = nothing</code>: an optional <a href="#SPIRV.ShaderCompilationCache"><code>ShaderCompilationCache</code></a> used to cache <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>s to prevent repeated compilation of SPIR-V modules.</li><li><code>interpreter = SPIRVInterpreter()</code>: a <a href="@ref"><code>SPIRVInterpreter</code></a> containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.</li><li><code>assemble = false</code>: a boolean flag indicating whether to assemble the resulting module into a <a href="#SPIRV.ShaderSource"><code>ShaderSource</code></a>, or leave it as a <a href="@ref"><code>Shader</code></a> for further introspection. If a cache is provided, <code>assemble</code> must be set to <code>true</code> for caching to be possible.</li></ul><p>See also: <a href="#SPIRV.@geometry-Tuple"><code>@geometry</code></a>, <a href="#SPIRV.@tessellation_control-Tuple"><code>@tessellation_control</code></a>, <a href="#SPIRV.@tessellation_evaluation-Tuple"><code>@tessellation_evaluation</code></a>, <a href="#SPIRV.@fragment-Tuple"><code>@fragment</code></a>, <a href="#SPIRV.@compute-Tuple"><code>@compute</code></a>, <a href="#SPIRV.@ray_generation-Tuple"><code>@ray_generation</code></a>, <a href="#SPIRV.@intersection-Tuple"><code>@intersection</code></a>, <a href="#SPIRV.@closest_hit-Tuple"><code>@closest_hit</code></a>, <a href="#SPIRV.@any_hit-Tuple"><code>@any_hit</code></a>, <a href="#SPIRV.@miss-Tuple"><code>@miss</code></a>, <a href="#SPIRV.@callable-Tuple"><code>@callable</code></a>, <a href="#SPIRV.@task-Tuple"><code>@task</code></a>, <a href="#SPIRV.@mesh-Tuple"><code>@mesh</code></a></p><p><strong>Extended help</strong></p><p><strong>Syntax reference</strong></p><p>The following syntax allows one to annotate function arguments with shader-specific information:</p><p><code>f([33m::Type[32m::StorageClass[39m[32m{[35m[BuiltIn][39m[38;5;168m, [@Decoration [= value]...][32m}[36m, ...)</code></p><p>For each argument, the following is to be provided:</p><ul><li><em>[33mREQUIRED[39m</em> An argument type.</li><li><em>[32mREQUIRED[39m</em> A SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_storage_class">storage class</a> (required).</li><li><em>[35mOPTIONAL[39m</em> A SPIR-V built-in category, see the <a href="https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap15.html#interfaces-builtin-variables">Vulkan built-in variables</a>.</li><li><em>[38;5;168mOPTIONAL[39m</em> One or more SPIR-V <a href="https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#_decoration">decorations</a>. Arguments to such decorations may be interpolated with <code>$</code>.</li></ul><p>This syntax is processed via <a href="@ref"><code>SPIRV.compile_shader</code></a>.</p><p><strong>Examples</strong></p><p>Here are a few examples using the described syntax:</p><p><code>@vertex [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[32m{[35mPosition[39m[38;5;168m[32m}[36m, [33m::UInt32[32m::Input[39m[32m{[35mVertexIndex[39m[38;5;168m[32m}[36m)</code></p><p><code>@fragment [parameters] f([33m::Vec4[32m::Input[39m[36m, [33m::InvocationData[32m::PushConstant[39m[36m)</code></p><p><code>@fragment [parameters] f([33m::Mutable{Vec4}[32m::Output[39m[36m, [33m::Vec4[32m::Input[39m[32m{[35mFragCoord[39m[38;5;168m[32m}[36m, [33m::Vec2[32m::Input[39m[32m{[38;5;168m@Flat[32m}[36m)</code></p><p><code>@compute [parameters] f([33m::UInt32[32m::Workgroup[39m[36m)</code></p><p><code>@compute [parameters] f([33m::Mutable{Arr{256, Float32}}[32m::Workgroup[39m[36m, [33m::UInt32[32m::Input[39m[32m{[35mLocalInvocationIndex[39m[38;5;168m[32m}[36m)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/frontend/shader/api.jl#LL25-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.Module" href="#SPIRV.Module"><code>SPIRV.Module</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Logical representation of a SPIR-V module.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/parse.jl#LL257-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.REGION_BLOCK" href="#SPIRV.REGION_BLOCK"><code>SPIRV.REGION_BLOCK</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>Sequence of blocks <code>u</code> ─→ [<code>v</code>, <code>vs...</code>] ─→ <code>w</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/analysis/structural_analysis.jl#LL17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SPIRV.OpCode" href="#SPIRV.OpCode"><code>SPIRV.OpCode</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Enumerated value representing the type of an instruction. See https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#<em>instructions</em>3 for a list of SPIR-V opcodes (excluding extended instruction sets).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/serenity4/SPIRV.jl/blob/9cc80cddbe4dc5c7b29882b00911cd1cd6c15d9b/src/SPIRV.jl#LL90-L93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../features/">« Features</a><a class="docs-footer-nextpage" href="../devdocs/">Developer documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Wednesday 31 July 2024 21:34">Wednesday 31 July 2024</span>. Using Julia version 1.12.0-DEV.958.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
