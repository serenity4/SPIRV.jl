var documenterSearchIndex = {"docs":
[{"location":"reference/bit_width/#Integer-and-float-bit-widths","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"","category":"section"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"When working on the CPU, most of the time there is little or no performance drawback in using 64-bit integers or floats compared to their 32-bit counterparts. However, when writing code aimed at GPU execution, it becomes important to understand that GPU architectures were designed around 32-bit integers and floats, while 64-bit values are expensive and may not even be supported on some hardware. For Vulkan for instance, reports on gpuinfo.org indicate that in 2024 only ~44% of known implementations support 64-bit float operations in shaders, and only ~53% support 64-bit integer operations (you may search for shaderFloat64 and shaderInt64 in the list to get the up-to-date metric).","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"While any decently modern hardware should in principle support these operations, the performance drawbacks encourage us to be more intentional about using 64-bit values, and to only do so if there is something to be gained from the additional precision or representation range.","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"In Julia, integer literals inherit the bit size of the host CPU architecture (Int, UInt), which is usually 64-bit, while float literals are always parsed as Float64. The problem becomes evident in light of the GPU limitations and potential lack of support with regard to such 64-bit values, and affects other types of devices as well.","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"Furthermore, 64-bit types may be internally used in some functions, such as this division operator:","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"julia> UInt32(1)/UInt32(3)\n0.3333333333333333\n\njulia> typeof(ans)\nFloat64","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"or even literal powers:","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"julia> 3f0^4\n81.0f0 # all fine, right?\n\n# Well, no:\njulia> @code_typed 3f0^4\nCodeInfo(\n1 ─      goto #2\n2 ─      goto #3\n3 ─      goto #4\n4 ─ %4 = Base.fpext(Base.Float64, x)::Float64\n│   %5 = Base.power_by_squaring::typeof(Base.power_by_squaring)\n│   %6 = invoke Base.:(var\"#power_by_squaring#528\")(Base.:*::typeof(*), %5::typeof(Base.power_by_squaring), %4::Float64, 4::Int64)::Float64\n│   %7 = Base.fptrunc(Base.Float32, %6)::Float32\n└──      goto #5\n5 ─      return %7\n) => Float32","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"To work around the related support and performance limitations on GPUs, one may need to perform explicit conversions to 32-bit types with Float32, Int32 and UInt32. To make it more convenient, SPIRV.jl defines symbols which, when right-multiplied, convert the input to the corresponding type:","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"Symbol Type Exported Example\nI Int32 no (x)I or x*I\nU UInt32 yes (x)U or x*U\nF Float32 yes (x)F or x*F","category":"page"},{"location":"reference/bit_width/","page":"Integer and float bit widths","title":"Integer and float bit widths","text":"A 32-bit floating-point representation of π is also exported as πF for convenience, defined as (π)F.","category":"page"},{"location":"reference/shader_compilation/#compiler","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"","category":"section"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"SPIRV.jl defines a Julia → SPIR-V compiler, built via the AbstractInterpreter interface. While standard compilation of Julia code emits LLVM IR to be turned into CPU machine code, this SPIR-V compiler emits SPIR-V IR aimed at consumption with a graphics API such as Vulkan. This compiler may be described equivalently as a Julia frontend for SPIR-V, or a SPIR-V backend for Julia.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"note: Note\nThis compiler only supports the Vulkan subset of SPIR-V. The OpenCL subset of SPIR-V is not a focus of this package at the moment.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"note: Note\nThis functionality requires Julia 1.11 or higher.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"warning: Warning\nThis compiler is largely experimental at the moment, and lacks real-world testing. Expect bugs and instabilities across Julia versions.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"The shaders are to be provided as regular Julia methods, but with restrictions: only a subset of Julia is supported (see Language support below), excluding exceptions, arrays, strings, and more.","category":"page"},{"location":"reference/shader_compilation/#Language-support","page":"Julia → SPIR-V compiler","title":"Language support","text":"","category":"section"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"The limitations imposed on Julia programs for SPIR-V compilation are the following:","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Special types are required to interface with the corresponding SPIR-V array, vector, matrix and image types (Arr, Vec, Mat, Image, SampledImage).\nStrings and Symbols are not supported, lacking SPIR-V counterparts.\nDynamic runtime features are not supported. This includes dynamic dispatch, isa type checks (unless elided by compile-time optimizations), invokelatest, tasks, and so on.\nUnion types are not supported, though there may be ways to support them in the future with some overhead.\nExceptions are not supported by SPIR-V.\nCalling external libraries via FFI is not supported by SPIR-V.\nRecursive functions are not supported by SPIR-V.\nArrays with an unspecified size are only allowed in restricted situations; see the conditions for such runtime arrays to be valid in Vulkan. However, if the PhysicalStorageBufferAddresses capability is enabled, you may use pointers and offsets instead (see @load and @store for this usage).\nPtr is not supported, but you may use @load and @store with UInt64 which use the internal SPIRV.Pointer type.\nStructs cannot access their fields dynamically, i.e. with a runtime index into their fields, even if they are all of the same type.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"A few additional limitations exist currently that may be removed in the future:","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Keyword arguments are not supported.\nMutable objects can be mutated, but will not see mutations to their mutable fields: if x.a is modified, x.a will return the modified value, but if x.a.b is modified, x.a.b will return the original value. This stems from a fundamental difference in the expression of mutability between Julia and SPIR-V, and may prove quite difficult to address reliably. For this reason, it is highly advised that you avoid relying on mutability in shader code.\nMethods attached to objects cannot be compiled, or only if the resulting code does not use its members. For this reason, prefer blur(x::GaussianBlur, ...) = compute_blur(x.strength, ...) to (x::GaussianBlur)(...) = compute_blur(x.strength). For this reason, closures (which are callable objects in disguise) should always be inlined so that they are optimized away.\nBase.ctlz and Base.cttz intrinsics to count leading and trailing zeroes, respectively.\nExpr(:throw_undef_if_not, ...) is not supported, forbidding to have programs that access a variable that may or may not have been defined depending on prior control-flow.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Due to these limitations, arbitrary Julia code is unlikely to compile successfully out of the box without a conscious effort to only operate in the allowed Julia language subset.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Regarding support for the SPIR-V language:","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Most basic SPIR-V instructions are covered.\nA few SPIR-V instructions are not covered yet, especially those related to advanced uses; if you need one that is missing, please file an issue or contact the developers directly. We aim to have all shader-related SPIR-V instructions added eventually.\nGLSL intrinsics are available via a corresponding method table overlay (which can be disabled).\nData layouts are automatically computed according to a LayoutStrategy.\nSPIR-V capabilities and extensions are automatically declared based on a user-provided FeatureSupport (see SupportedFeatures to specify the exact set of features supported by a given driver).\nVulkan features and extensions are automatically translated to SPIR-V capabilities and features, provided by a Vulkan.jl package extension that adds a constructor to SupportedFeatures.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Any Julia program that you can write in perspective of being compiled to SPIR-V should be executable on the CPU, unless they rely on specific configurations of the SPIR-V execution environment. For instance, filtered image operations are not supported for CPU execution, nor are derivative operations or group operations, to cite a few.","category":"page"},{"location":"reference/shader_compilation/#Targeting-SPIR-V-via-LLVM","page":"Julia → SPIR-V compiler","title":"Targeting SPIR-V via LLVM","text":"","category":"section"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"As described in the introduction, SPIR-V and LLVM IR are both formats to describe programs; but behind the apparent similarity lie fundamental differences between the two. Most importantly, the SPIR-V subset relevant for graphics workloads is in its current state incompatible with LLVM IR.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"There exists a SPIR-V to LLVM bidirectional translator, but the project title omits one thing: only the OpenCL subset of SPIR-V is supported. Adding support for the graphics subset would be a tedious task; see this issue comment for more details about a few of the challenges involved.","category":"page"},{"location":"reference/shader_compilation/","page":"Julia → SPIR-V compiler","title":"Julia → SPIR-V compiler","text":"Therefore, we cannot rely on LLVM tooling to generate SPIR-V from Julia code; that is unfortunate, as we otherwise might have been able to use the GPUCompiler.jl infrastructure. One promising approach so far is to target SPIR-V from Julia IR using the AbstractInterpreter interface, hooking into Julia's compilation pipeline in a way that is similar to GPUCompiler.jl until we bifurcate to emit SPIR-V IR instead of LLVM IR.","category":"page"},{"location":"ir/#IR","page":"IR","title":"IR","text":"","category":"section"},{"location":"ir/","page":"IR","title":"IR","text":"No transformations are carried out on Julia typed IR.","category":"page"},{"location":"ir/","page":"IR","title":"IR","text":"This typed IR will be translated into unstructured SPIR-V IR by mapping instructions from one IR to the other. This unstructured IR will be restructured by applying the following transformations:","category":"page"},{"location":"ir/","page":"IR","title":"IR","text":"Node cloning to make turn irreducible control-flow into reducible control-flow.\nRestructuring with the help of a control tree from structural analysis. Insertion of selection and loop merge information will be incorporated into the IR.","category":"page"},{"location":"ir/","page":"IR","title":"IR","text":"This will turn SPIR-V IR into a standard format that will be assumed during the rest of the compilation pipeline, including optimizations and final introspection to exhibit implicit shader interfaces (e.g. an unsigned integer converted to a pointer and loaded from). Having a standardized and structured control-flow will enable simplifications and speed-ups in control-flow and data-flow analyses.","category":"page"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"SPIR-V defines a binary format for GPU code. It is an intermediate representation (IR), similar in surface to LLVM IR for CPUs. It contains two major subsets, one being used by compute APIs (such as OpenCL and OneAPI), the other being used by graphics APIs (Vulkan and OpenGL, mostly). The two are incompatible with each other, but have enough overlap that they are expressed within the same format.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"While most GPUs models expose a common vendor-specific assembly-like IR for compute APIs (such as PTX for NVIDIA and GCN for AMD), shaders used by graphics APIs rarely map to any clearly-defined assembly language. Notably, the way graphics shaders are run on the GPU is very often GPU-specific, not only specific to vendors but also to GPU models and architectures.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the world of graphics, SPIR-V is the closest that one can get to an assembly language for most GPUs. This is partly owed to the fact that graphics shaders come with a lot of state, and a shader can in most cases be thought of a program and an execution environment bundled together. As a consequence, SPIR-V defines a format for specifying both the program and its execution environment through the use of features and special intrinsics.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This disparity between compute IRs and the lack of proper graphics IRs makes it so that SPIR-V only maps well to LLVM IR for its OpenCL subset. Graphics rendering relies a lot on shader-specific notions at the hardware level, such as uniform buffers, textures, attachments, push constants, fragment derivative operations, and more. This is difficult to properly express with LLVM IR, because those notions are only related to graphics processing; in fact, they are relevant mainly because they speed up graphics rendering by expressing semantics that map to specialized hardware features.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This library currently targets the Vulkan subset of SPIR-V, aimed at manipulating shaders. However, this library also contains general functionality such as assembling/disassembling SPIR-V, independent of the SPIR-V subset used, which OpenCL users may find somewhat useful.","category":"page"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/#Reading,-introspecting-into-and-writing-SPIR-V-modules","page":"Features","title":"Reading, introspecting into and writing SPIR-V modules","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"SPIR-V can be read in its binary format (usually ending in .spv), or can be parsed as a human-understandable format (usually ending in .spvasm).","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"A SPIR-V module can be disassembled to an IO to print a human-understandable output.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"It can also be assembled to a binary format, usually to be saved on disk or to be used by a consumer of SPIR-V code (e.g. Vulkan).","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"An IR structure is also available to reason about a given SPIR-V module globally, and not just as a stream of instructions. This form is suited for introspection and modification. It can then be converted back to a SPIR-V module. Note that a module converted to an IR which is converted back to a module will not be identical, even if no modification was made to the IR; the ordering of certain instructions (such as debugging instructions) may not be the same, although there will be no change of semantics.","category":"page"},{"location":"reference/known_bugs/#Known-bugs","page":"Known bugs","title":"Known bugs","text":"","category":"section"},{"location":"reference/known_bugs/","page":"Known bugs","title":"Known bugs","text":"Here is a collection of bugs that have occurred in the past related to SPIR-V code generation, to hopefully help debug any driver hangs or crashes. Most SPIR-V violations are caught with the SPIR-V validator, but sometimes others go unnoticed because they come from unusual but legal SPIR-V that drivers may have a hard time with. We will only list possible driver bugs that arise with legal SPIR-V, as validation bugs are easy to catch.","category":"page"},{"location":"reference/known_bugs/","page":"Known bugs","title":"Known bugs","text":"This page should not be useful to most users, unless you are actively trying to debug a crash that is known to emanate from a specific SPIR-V module.","category":"page"},{"location":"reference/known_bugs/#Vulkan","page":"Known bugs","title":"Vulkan","text":"","category":"section"},{"location":"reference/known_bugs/","page":"Known bugs","title":"Known bugs","text":"Bugs triggered using the Vulkan API.","category":"page"},{"location":"reference/known_bugs/#Hangs-during-pipeline-creation","page":"Known bugs","title":"Hangs during pipeline creation","text":"","category":"section"},{"location":"reference/known_bugs/","page":"Known bugs","title":"Known bugs","text":"The final compilation of shaders into machine code occurs at pipeline creation, i.e. vkCreateGraphicsPipelines, vkCreateComputePipelines and similar functions for more advanced pipelines such as ray-tracing pipelines.","category":"page"},{"location":"reference/known_bugs/","page":"Known bugs","title":"Known bugs","text":"TODO","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"EditURL = \"manipulating_spirv.jl\"","category":"page"},{"location":"tutorials/manipulating_spirv/#Manipulating-SPIR-V-binaries","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"","category":"section"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"SPIR-V is a binary format. One implication is that introspecting into SPIR-V code requires specialized tools to read and make sense of the data.","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"In this package, we provide ways to read binaries from files or IO streams. Depending on how much you want your SPIR-V binaries to be analyzed, we provide a few data structures:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"PhysicalModule, which is a thin wrapper over the general SPIR-V format. Instructions are parsed into PhysicalInstructions, which encode the most basic structure of a SPIR-V instruction. This data structure is used exclusively for serialization/deserialization purposes, and little can be done with it beyond that.\nSPIRV.Module, which preserves the general layout of a SPIR-V module and adds more information about its logical layout. Notably, instructions use the Instruction data structure which encodes logical information about their semantics (SPIRV.OpCode), type and result identifiers (ResultID), and any arguments parsed into Julia types (Float32, Float64, etc). Pretty-printing is provided for SPIRV.Modules, which will show the SPIR-V module in colored human-readable text to MIME\"text/plain\" outputs.\nIR, which splits a SPIR-V module into many secondary associative data structures, grouped by semantics. This is the best form to inspect logical sections of SPIR-V modules such as functions, types, or constants. It may be constructed by hand or from a SPIRV.Module, and is convertible to a SPIRV.Module by aggregating all of the logical sections and serializing them into an instruction stream.","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"Let's first start by looking at the first data structure, PhysicalModule. We will use a tiny vertex shader in SPIR-V form as our binary file.","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"using SPIRV, Test\n\nbytes = read(joinpath(@__DIR__, \"vert.spv\"))","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"pmod = PhysicalModule(bytes)\npmod.instructions","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"There isn't much to look at here. We can assemble this module back into a sequence of words:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"words = assemble(pmod)","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"which is identical to the sequence of bytes we originally had:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"@test reinterpret(UInt8, words) == bytes","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"To see better into our SPIR-V binary, let's parse it into a SPIRV.Module and pretty-print its contents:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"mod = SPIRV.Module(bytes)","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"Contents still remain unchanged. Let's prove that:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"@test assemble(mod) == words","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"Now, let's go all the way and do some work to understand the contents of this SPIR-V module:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"ir = IR(bytes)","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"The IR is still printed as an instruction stream, but that is only for pretty-printing; the data structure itself loses the sequential layout of the module. Pretty-printing first transforms the IR into a SPIRV.Module, then uses some of the information stored in the IR to enhance the display. Notice how certain previously numbered variable names were substituted with actual variable names, such as %frag_color.","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"This IR data structure is not public, in the sense that we do not commit to a stable semantically versioned implementation; it has notably been designed in context of the Julia to SPIR-V compiler, which is still experimental. However, if you want to explore a given SPIR-V module, you can try to make sense of its contents:","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"ir.fdefs","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"ir.constants","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"ir.types","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"ir.capabilities","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"Let's now assemble it into a sequence of instructions. Note that the regenerated module may slightly differ from the original module; extra metadata may be added or removed.","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"regenerated = SPIRV.Module(ir)\n\nsetdiff(mod, regenerated)","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"setdiff(regenerated, mod)","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"","category":"page"},{"location":"tutorials/manipulating_spirv/","page":"Manipulating SPIR-V binaries","title":"Manipulating SPIR-V binaries","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"warning: Warning\nThis section is incomplete. Readers are kindly encouraged to go through the tests and source code for more information about the API usage.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [SPIRV]\nPrivate = false","category":"page"},{"location":"api/#SPIRV.πF","page":"API","title":"SPIRV.πF","text":"32-bit floating-point representation of π.\n\n\n\n\n\n","category":"constant"},{"location":"api/#SPIRV.AnnotatedModule","page":"API","title":"SPIRV.AnnotatedModule","text":"Module annotated with instruction ranges for each logical SPIR-V section, suitable for read-only operations and analyses.\n\nAny desired modifications of annotated modules should be staged and applied via a Diff.\n\nwarn: Warn\nThis module should not be modified, and in particular must not have its structure affected in any way by the insertion or removal of instructions. Modifications can cause the annotations to become out of sync with the updated state of the module, yielding undefined behavior.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.ControlTree","page":"API","title":"SPIRV.ControlTree","text":"Control tree.\n\nThe leaves are labeled as REGION_BLOCK regions, with the distinguishing property that they have no children.\n\nChildren nodes of any given subtree are in reverse postorder according to the original control-flow graph.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.DeltaGraph","page":"API","title":"SPIRV.DeltaGraph","text":"Graph whose vertices and edges remain identical after deletion of other vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.F","page":"API","title":"SPIRV.F","text":"x*F\n(x)F\n\nConverts an input x to a Float32 when F is right-multiplied with it.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.FeatureSupport","page":"API","title":"SPIRV.FeatureSupport","text":"Abstract type expressing SPIR-V which capabilities and extensions are supported.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.IR","page":"API","title":"SPIRV.IR","text":"Intermediate representation of SPIR-V modules.\n\nThe types and constants mappings can be updated at any time without explicitly notifying of the mutation behavior (i.e. functions may not end with !), so long as additions only are performed. Such additions are currently done upon construction of GlobalsInfo. The ID counter can also be incremented without notice.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.Image","page":"API","title":"SPIRV.Image","text":"SPIR-V image type.\n\nType parameters:\n\nFormat: SPIR-V ImageFormat enumerated value.\nDim: SPIR-V Dim enumerated value.\nDepth: 64-bit integer with value 0 (not a depth image), 1 (depth image) or 2 (unknown).\nArrayed: Bool indicating whether the image is a layer of an image array.\nMS: Bool indicating whether the image is multisampled.\nSampled: 64-bit integer with value 0 (unknown), 1 (may be sampled) or 2 (read-write, no sampling).\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.Instruction","page":"API","title":"SPIRV.Instruction","text":"Parsed SPIR-V instruction. It represents an instruction of the form %result_id = %opcode(%arguments...)::%type_id.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.LayoutStrategy","page":"API","title":"SPIRV.LayoutStrategy","text":"Layout strategy used to compute alignments, offsets and strides.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.NativeLayout","page":"API","title":"SPIRV.NativeLayout","text":"\" Julia layout, with a special handling of mutable fields for composite types.\n\nMutable fields are stored as 8-byte pointers in Julia, but in SPIR-V there is no such concept of pointer. Therefore, we treat mutable fields as if they were fully inlined - that imposes a few restrictions on the behavior of such mutable objects, but is necessary to keep some form of compatibility with GPU representations. The alternative would be to completely disallow structs which contain mutable fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.NoPadding","page":"API","title":"SPIRV.NoPadding","text":"Layout strategy which assumes no padding is required at all. This might be useful for maximally packing data when serialized, reducing size; or to improve performance by avoiding padding when not needed, e.g. if you already pad your structures manually upfront (only do that if you know what you're doing).\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.PhysicalInstruction","page":"API","title":"SPIRV.PhysicalInstruction","text":"SPIR-V instruction in binary format.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.PhysicalModule","page":"API","title":"SPIRV.PhysicalModule","text":"SPIR-V module, as a series of headers followed by a stream of instructions. The header embeds two magic numbers, one for the module itself and one for the tool that generated it (e.g. glslang). It also contains the version of the specification applicable to the module, the maximum ID number and an optional instruction schema.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.ResultID","page":"API","title":"SPIRV.ResultID","text":"Result ID used in a SPIR-V context, following single static assignment rules for valid modules.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.SPIRVTarget","page":"API","title":"SPIRV.SPIRVTarget","text":"SPIR-V target for compilation through the Julia frontend.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.ShaderCompilationCache","page":"API","title":"SPIRV.ShaderCompilationCache","text":"ShaderCompilationCache()\n\nCreate a cache that may be used to associate shaders to be compiled (ShaderInfo) with compiled code (ShaderSource).\n\nAlthough this cache will already significantly speed up shader creation by compiling only what is required, performance-critical applications will additionally want to use a high-level cache that maps a ShaderSource to a driver-dependent object generated by the graphics API chosen for that application. For Vulkan, that would be a Vk.ShaderModule, for example. It is then recommended to use an IdDict to perform the caching, to avoid hashing the whole source code.\n\nwarning: Warning\nCaching assumes the same SPIRVInterpreter to be used, and will not look into the ShaderSource's interp field. Generally, applications should use a single interpreter, and not fiddle with parameters across different shader compilation runs. This allows caching to skip hashing SPIRVInterpreter contents needlessly in what should be >99.9% of cases.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.ShaderLayout","page":"API","title":"SPIRV.ShaderLayout","text":"Shader-compatible layout strategy, where layout information is strictly read from shader decorations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.ShaderSource","page":"API","title":"SPIRV.ShaderSource","text":"SPIR-V shader code, with stage and entry point information.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.StructType","page":"API","title":"SPIRV.StructType","text":"SPIR-V aggregate type.\n\nEquality is defined in terms of identity, since different aggregate types have in principle different semantics.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.SupportedFeatures","page":"API","title":"SPIRV.SupportedFeatures","text":"Extensions and capabilities supported by a client API.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.TypeMetadata","page":"API","title":"SPIRV.TypeMetadata","text":"Type metadata meant to be analyzed and modified to generate appropriate decorations.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.U","page":"API","title":"SPIRV.U","text":"x*U\n(x)U\n\nConverts an input x to an UInt32 when U is right-multiplied with it.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.VulkanLayout","page":"API","title":"SPIRV.VulkanLayout","text":"Vulkan-compatible layout strategy.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.alignment","page":"API","title":"SPIRV.alignment","text":"alignment(layout, T)\n\nMemory alignment which must be respected when allocating a value of the given type.\n\nThis refers to an external alignment, i.e. this value is of interest when allocating a value of type T within a struct or array. In particular, this value does not indicate what should be the alignment of any struct member or the stride of any array element contained in T, if T is a struct or an array.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPIRV.datasize","page":"API","title":"SPIRV.datasize","text":"datasize(layout, T)\n\nThis is the total space occupied by a value of type T, including padding between struct elements and array strides.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPIRV.disassemble-Tuple{IO, SPIRV.Module}","page":"API","title":"SPIRV.disassemble","text":"disassemble(io, spir_module)\n\nTransform the content of spir_module into a human-readable format and prints it to io.\n\n\n\n\n\n","category":"method"},{"location":"api/#SPIRV.spir_type","page":"API","title":"SPIRV.spir_type","text":"Get a SPIR-V type from a Julia type, caching the mapping in the IR if one is provided.\n\n\n\n\n\n","category":"function"},{"location":"api/#SPIRV.@any_hit-Tuple","page":"API","title":"SPIRV.@any_hit","text":"@any_hit [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a any_hit shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing any_hit-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@callable-Tuple","page":"API","title":"SPIRV.@callable","text":"@callable [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a callable shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing callable-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@closest_hit-Tuple","page":"API","title":"SPIRV.@closest_hit","text":"@closest_hit [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a closest_hit shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing closest_hit-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@compute-Tuple","page":"API","title":"SPIRV.@compute","text":"@compute [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a compute shader.\n\nThe supported parameters are the following:\n\noptions = ComputeExecutionOptions(): a ComputeExecutionOptions structure providing compute-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@for","page":"API","title":"SPIRV.@for","text":"@for i in iter begin #= ... do something with i ... =# end   @for i in iter1, j in iter2 begin #= ... do something with i and j ... =# end\n\nDefine a C-style for loop.\n\nThis loop does not rely on the standard iteration protocol in Julia, and will instead mimic how loops work in C: a loop entry point usually defines loop variables, a condition guards the loop body, and a continue block usually increments loop variables on subsequent iterations.\n\niter must implement pre_loop, cond_loop and post_loop.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@fragment-Tuple","page":"API","title":"SPIRV.@fragment","text":"@fragment [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a fragment shader.\n\nThe supported parameters are the following:\n\noptions = FragmentExecutionOptions(): a FragmentExecutionOptions structure providing fragment-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@geometry-Tuple","page":"API","title":"SPIRV.@geometry","text":"@geometry [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a geometry shader.\n\nThe supported parameters are the following:\n\noptions = GeometryExecutionOptions(): a GeometryExecutionOptions structure providing geometry-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@intersection-Tuple","page":"API","title":"SPIRV.@intersection","text":"@intersection [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a intersection shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing intersection-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@load-Tuple{Any}","page":"API","title":"SPIRV.@load","text":"@load address::T\n@load address[index]::T\n\nLoad a value of type T, either directly (if no index is specified) or at offset = index - 1 elements from address. address should be a device address, i.e. a UInt64 value representing the address of a physical storage buffer.\n\nnote: Note\nAlthough @load address::T and @load address[1]::T look semantically the same, you should use whichever is appropriate given the underlying data; if you have an array pointer, use the latter, and if you have a pointer to a single element, use the former. Otherwise, executing this on the CPU will most likely crash if attempted with a T that is a mutable type, because mutable elements are stored as object pointers in arrays, requiring an extra bit of indirection that is expressed by @load address[1]::T if one wants to get the correct address.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@mesh-Tuple","page":"API","title":"SPIRV.@mesh","text":"@mesh [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a mesh shader.\n\nThe supported parameters are the following:\n\noptions = MeshExecutionOptions(): a MeshExecutionOptions structure providing mesh-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@miss-Tuple","page":"API","title":"SPIRV.@miss","text":"@miss [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a miss shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing miss-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@ray_generation-Tuple","page":"API","title":"SPIRV.@ray_generation","text":"@ray_generation [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a ray_generation shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing ray_generation-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@store","page":"API","title":"SPIRV.@store","text":"@store value address::T\n@store value address[index]::T\n@store address::T = value\n@store address[index]::T = value\n\nStore a value of type T at the given address, either directly (if no index is specified) or at an offset of index - 1 elements from address.\n\nIf value is not of type T, a conversion will be attempted.\n\naddress should be a device address, i.e. a UInt64 value representing the address of a physical storage buffer.\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@task-Tuple","page":"API","title":"SPIRV.@task","text":"@task [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a task shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing task-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@tessellation_control-Tuple","page":"API","title":"SPIRV.@tessellation_control","text":"@tessellation_control [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a tessellation_control shader.\n\nThe supported parameters are the following:\n\noptions = TessellationExecutionOptions(): a TessellationExecutionOptions structure providing tessellation_control-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@tessellation_evaluation-Tuple","page":"API","title":"SPIRV.@tessellation_evaluation","text":"@tessellation_evaluation [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a tessellation_evaluation shader.\n\nThe supported parameters are the following:\n\noptions = TessellationExecutionOptions(): a TessellationExecutionOptions structure providing tessellation_evaluation-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @vertex, @geometry, @tessellation_control, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/#SPIRV.@vertex-Tuple","page":"API","title":"SPIRV.@vertex","text":"@vertex [parameters] f(::Type1::StorageClass1[{...}], ...)\n\nCompile the provided signature f(args...) into a vertex shader.\n\nThe supported parameters are the following:\n\noptions = CommonExecutionOptions(): a CommonExecutionOptions structure providing vertex-specific options.\nfeatures = AllSupported(): a SPIRV.FeatureSupport structure informing the SPIR-V compiler\n\nwhat capabilities and extensions are allowed. In application code, this should generally be a SupportedFeatures structure coming from the client API. For instance, a package extension for Vulkan.jl exists which provides SupportedFeatures(physical_device, api_version, device_extensions, device_features).\n\nlayout = VulkanLayout(): a VulkanLayout to use to compute alignments, strides and offsets in structures and arrays.\ncache = nothing: an optional ShaderCompilationCache used to cache ShaderSources to prevent repeated compilation of SPIR-V modules.\ninterpreter = SPIRVInterpreter(): a SPIRVInterpreter containing method tables and optimization options for the computation. If a cache is provided, this interpreter must be identical to the one used to compile all previous cache entries.\nassemble = false: a boolean flag indicating whether to assemble the resulting module into a ShaderSource, or leave it as a Shader for further introspection. If a cache is provided, assemble must be set to true for caching to be possible.\n\nSee also: @geometry, @tessellation_control, @tessellation_evaluation, @fragment, @compute, @ray_generation, @intersection, @closest_hit, @any_hit, @miss, @callable, @task, @mesh\n\nExtended help\n\nSyntax reference\n\nThe following syntax allows one to annotate function arguments with shader-specific information:\n\nf(\u001b[33m::Type\u001b[32m::StorageClass\u001b[39m\u001b[32m{\u001b[35m[BuiltIn]\u001b[39m\u001b[38;5;168m, [@Decoration [= value]...]\u001b[32m}\u001b[36m, ...)\n\nFor each argument, the following is to be provided:\n\n\u001b[33mREQUIRED\u001b[39m An argument type.\n\u001b[32mREQUIRED\u001b[39m A SPIR-V storage class (required).\n\u001b[35mOPTIONAL\u001b[39m A SPIR-V built-in category, see the Vulkan built-in variables.\n\u001b[38;5;168mOPTIONAL\u001b[39m One or more SPIR-V decorations. Arguments to such decorations may be interpolated with $.\n\nThis syntax is processed via SPIRV.compile_shader.\n\nExamples\n\nHere are a few examples using the described syntax:\n\n@vertex [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[32m{\u001b[35mPosition\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mVertexIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[36m, \u001b[33m::InvocationData\u001b[32m::PushConstant\u001b[39m\u001b[36m)\n\n@fragment [parameters] f(\u001b[33m::Mutable{Vec4}\u001b[32m::Output\u001b[39m\u001b[36m, \u001b[33m::Vec4\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mFragCoord\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m, \u001b[33m::Vec2\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[38;5;168m@Flat\u001b[32m}\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::UInt32\u001b[32m::Workgroup\u001b[39m\u001b[36m)\n\n@compute [parameters] f(\u001b[33m::Mutable{Arr{256, Float32}}\u001b[32m::Workgroup\u001b[39m\u001b[36m, \u001b[33m::UInt32\u001b[32m::Input\u001b[39m\u001b[32m{\u001b[35mLocalInvocationIndex\u001b[39m\u001b[38;5;168m\u001b[32m}\u001b[36m)\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"SPIRV.Module\nSPIRV.REGION_BLOCK\nSPIRV.OpCode","category":"page"},{"location":"api/#SPIRV.Module","page":"API","title":"SPIRV.Module","text":"Logical representation of a SPIR-V module.\n\n\n\n\n\n","category":"type"},{"location":"api/#SPIRV.REGION_BLOCK","page":"API","title":"SPIRV.REGION_BLOCK","text":"Sequence of blocks u ─→ [v, vs...] ─→ w\n\n\n\n\n\n","category":"constant"},{"location":"api/#SPIRV.OpCode","page":"API","title":"SPIRV.OpCode","text":"Enumerated value representing the type of an instruction. See https://registry.khronos.org/SPIR-V/specs/unified1/SPIRV.html#instructions3 for a list of SPIR-V opcodes (excluding extended instruction sets).\n\n\n\n\n\n","category":"type"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"EditURL = \"creating_a_shader.jl\"","category":"page"},{"location":"tutorials/creating_a_shader/#tutorial-creating-a-shader","page":"Creating a shader","title":"Creating a shader","text":"","category":"section"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"This tutorial will show you how to:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Create a SPIR-V shader using the experimental Julia → SPIR-V compiler.\nExecute it using Vulkan.jl.","category":"page"},{"location":"tutorials/creating_a_shader/#tutorial-compiling-a-shader","page":"Creating a shader","title":"Compiling a shader","text":"","category":"section"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"To create a shader, a method is to be defined that will typically mutate some built-in output variables, and may interact with GPU memory.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We will first quickly show how to compile a simplistic fragment shader, then move on to compiling a compute shader that we will execute in the second part of this tutorial.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Let's for example define a fragment shader that colors all pixels with the same color. We'll be using Swizzles.jl, which allows us to conveniently use color-related property names and store to various subparts of a vector efficiently.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: Vec3, Vec4, Mutable\nusing Swizzles: @swizzle\n\nstruct FragmentData\n  color::Vec3\n  alpha::Float32\nend\n\nfunction fragment_shader!(color::Mutable{Vec4}, data::FragmentData)\n  @swizzle color.rgb = data.color\n  @swizzle color.a = data.alpha\nend","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"This is a regular Julia function, which we may quickly test on the CPU first.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"color = Mutable(Vec4(0, 0, 0, 0))\nwhite = Vec3(1, 1, 1)\ndata = FragmentData(white, 1)\nfragment_shader!(color, data)\n@assert color[1:3] == data.color\n@assert color[4] == data.alpha","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Let's compile this shader. We'll also need to specify where the arguments will come from at the time of execution, as we can't provide it with values as we would a Julia function.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"In Vulkan, the value of the current pixel is encoded as a variable in the Output storage class, assuming we want to write to the first (and usually the only one) color attachment of the render pass that this shader will be executed within.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"As for the FragmentData, there are a couple of possibilities; we can for example put that into a push constant, though a uniform buffer would have worked just as well.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We will specify this information using the @fragment macro, which accepts a handy syntax to annotate these arguments:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: @fragment\n\nshader = @fragment fragment_shader!(\n  ::Mutable{Vec4}::Output,\n  ::FragmentData::PushConstant\n);\nnothing #hide","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"There are multiple parameters to @fragment, but we'll stick with the defaults for now. Normally, we would at least provide a features parameter, which defines the set of features and extensions supported by our GPU for SPIR-V. The default assumes any feature or extension is allowed. We'll be able to accurately specify our GPU feature support when we query it via a graphics API, e.g. Vulkan.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Let's take a look at what we got!","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"shader","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: validate\n\nvalidate(shader)","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Neat! How should we execute it on the GPU now?","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"... Well, we can't, actually; or at least, not with SPIRV.jl alone. SPIR-V is an IR used by graphics APIs, so you will need a graphics API to run anything. And, as you probably know, we'll also need a vertex shader to run a fragment shader.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Let's now define our compute shdaer. We'll try to make it less trivial than our previous fragment shader. This time, we'll exponentiate a buffer where each invocation mutates a specific entry in that buffer.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We could setup a storage buffer, but for simplicity, we'll work with a memory address and a size instead, C-style, using the @load and @store utilities provided by SPIRV.jl.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: @load, @store, @vec, U, Vec3U\nusing StaticArrays\nusing SPIRV.MathFunctions: linear_index\n\nstruct ComputeData\n  buffer::UInt64 # memory address of a buffer\n  size::UInt32 # buffer size\nend\n\nfunction compute_shader!((; buffer, size)::ComputeData, global_id::Vec3U)\n  # `global_id` is zero-based, coming from Vulkan; but we're now in Julia,\n  # where everything is one-based.\n  index = global_id.x + 1U\n  value = @load buffer[index]::Float32\n  result = exp(value)\n  1U ≤ index ≤ size && @store result buffer[index]::Float32\n  nothing\nend","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"For the index into our vector of values, we'll rely on using one-dimensional workgroups to then use the current index among all dispatched invocations. SPIR-V provides the GlobalInvocationId built-in, which will be fed with this value.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"You may notice that we use 1U, which is simply some sugar syntax for UInt32(1). We don't use the plain literal 1. because we don't want index to widen to an Int64. See Integer and float bit widths for more details.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We can run this shader on the CPU to test it first, but it's a bit more hacky this time since we chose to work with a memory address.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Nonetheless, it's completely valid to take a pointer from an array and convert it to a UInt64, we can therefore proceed!","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"array = ones(Float32, 256)\n\nGC.@preserve array begin\n  ptr = pointer(array)\n  address = UInt64(ptr)\n  data = ComputeData(address, length(array))\n  compute_shader!(data, @vec UInt32[0, 0, 0])\n  compute_shader!(data, @vec UInt32[5, 0, 0])\nend\n\narray","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"All good! Let's now turn it into a SPIR-V shader. Same as before, let's assume we'll provide the ComputeData with a push constant.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We'll also specify the workgroup size (or local invocation size, in SPIR-V terms, from the LocalSize execution mode). Let's set it to 64 x 1 x 1, and rely on it being later invoked with at least 4 workgroups to cover all 256 array elements. We could also go with a two-dimensional pattern, such as 8 x 8 x 1, but then we'd need to do extra math in our shader to derive a linear index from a two-dimensional index, unnecessarily complicating things.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: @compute, ComputeExecutionOptions\n\nshader = @compute compute_shader!(\n  ::ComputeData::PushConstant,\n  ::Vec3U::Input{GlobalInvocationId},\n) options = ComputeExecutionOptions(local_size = (64, 1, 1))","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"validate(shader)","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Et voilà! Notice the LocalSizeId execution mode pointing to the constants (64, 1, 1) in the corresponding IR.","category":"page"},{"location":"tutorials/creating_a_shader/#Executing-a-shader-with-Vulkan","page":"Creating a shader","title":"Executing a shader with Vulkan","text":"","category":"section"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"After compiling a shader, the next logical step is to execute it. This requires the help of a graphics API that uses SPIR-V, such as Vulkan or OpenGL (with the corresponding SPIR-V extension). We will use Vulkan via Vulkan.jl.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"As Vulkan usage falls out of scope of this documentation, we will not detail nor comment the steps used to setup everything, beyond inline code comments. Furthermore, note that the code shown is designed to execute this specific compute shader. For resources about Vulkan API usage, please consult the Vulkan.jl documentation as well as other Vulkan tutorials out there.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"To proceed, we will need to interface with the Vulkan loader with a Vk.Instance, and pick a device on which to execute our shader.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: SupportedFeatures, check_compiler_feature_requirements\nusing Vulkan: Vk, VkCore, unwrap","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Create callback for logging and error reporting.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"debug_callback_c = @cfunction(Vk.default_debug_callback, UInt32, (Vk.DebugUtilsMessageSeverityFlagEXT, Vk.DebugUtilsMessageTypeFlagEXT, Ptr{VkCore.VkDebugUtilsMessengerCallbackDataEXT}, Ptr{Cvoid}))\n\nfunction create_device()\n  # Use the validation layers.\n  layers = String[\"VK_LAYER_KHRONOS_validation\"]\n  # Enable logging.\n  extensions = String[\"VK_EXT_debug_utils\"]\n  instance = Vk.Instance(layers, extensions; application_info = Vk.ApplicationInfo(v\"0.1\", v\"0.1\", v\"1.3\"))\n  debug_messenger = Vk.DebugUtilsMessengerEXT(instance, debug_callback_c)\n\n  # Pick the first physical device that we find.\n  physical_device = first(unwrap(Vk.enumerate_physical_devices(instance)))\n  @info \"Selected $(Vk.get_physical_device_properties(physical_device))\"\n\n  # Request Vulkan API features necessary for the usage with SPIRV.jl\n  device_features_1_1 = Vk.PhysicalDeviceVulkan11Features(:variable_pointers, :variable_pointers_storage_buffer)\n  device_features_1_2 = Vk.PhysicalDeviceVulkan12Features(:buffer_device_address, :vulkan_memory_model; next = device_features_1_1)\n  device_features_1_3 = Vk.PhysicalDeviceVulkan13Features(:synchronization2, :dynamic_rendering, :shader_integer_dot_product, :maintenance4; next = device_features_1_2)\n  device_features = Vk.PhysicalDeviceFeatures2(Vk.PhysicalDeviceFeatures(:shader_float_64, :shader_int_64); next = device_features_1_3)\n\n  # Create the device requesting a queue that supports graphics and compute operations.\n  device_extensions = String[]\n  queue_family_index = Vk.find_queue_family(physical_device, Vk.QUEUE_GRAPHICS_BIT | Vk.QUEUE_COMPUTE_BIT)\n  device = Vk.Device(\n    physical_device,\n    [Vk.DeviceQueueCreateInfo(queue_family_index, [1.0])],\n    [], device_extensions; next = device_features\n  )\n\n  # Query all of the supported SPIR-V features, to be communicated to the Julia → SPIR-V compiler.\n  supported_features = SupportedFeatures(physical_device, v\"1.3\", device_extensions, device_features)\n  # Check that we have the basic features that the compiler will require.\n  check_compiler_feature_requirements(supported_features)\n\n  (; debug_messenger, device, queue_family_index, supported_features)\nend\n\n(; debug_messenger, device, queue_family_index, supported_features) = create_device();\nnothing #hide","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Great. We'll take the one from the previous tutorial, which we already know how to compile.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"However, this time we'll create a SPIRV.ShaderSource, which represents a SPIRV.Shader assembled into a word vector, using the macro parameter assemble = true. We'll also fill in the features parameter, such that we are guaranteed that the Julia → SPIR-V compiler returns a shader that is compatible with our Vulkan API usage.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"source = @compute features = supported_features assemble = true compute_shader!(\n  ::ComputeData::PushConstant,\n  ::Vec3U::Input{GlobalInvocationId},\n  ) options = ComputeExecutionOptions(local_size = (64, 1, 1))","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Here comes the hard part. To submit our shader for execution, we need to:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Provide Vulkan with our shader.\nConstruct a buffer on the device that holds our Vector data, then get its memory address.\nBuild a command buffer and submit the appropriate commands to invoke our compute shader.\nWait for the computation to finish and copy the results into our original Vector.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"This is all quite verbose, but with Vulkan, this is expected.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using SPIRV: ShaderSource, serialize\n\n\"\"\"\nExecute a shader on the provided device and return the result, which **must** be of type `T`.\n\"\"\"\nfunction execute_shader(source::ShaderSource, device::Vk.Device, queue_family_index, array::Vector{Float32})\n  # Provide Vulkan with our shader.\n  stage = Vk.ShaderStageFlag(source.info.interface.execution_model)\n  @assert stage == Vk.SHADER_STAGE_COMPUTE_BIT\n  shader = Vk.ShaderModule(device, source)\n\n  # Construct a buffer on the device.\n  buffer = Vk.Buffer(device, sizeof(array), Vk.BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT, Vk.SHARING_MODE_EXCLUSIVE, [queue_family_index])\n  # Allocate memory for it, selecting a memory that is host-visible and host-coherent.\n  memory_requirements = Vk.get_buffer_memory_requirements(device, buffer)\n  memory_index = find_memory_type(device.physical_device, memory_requirements.memory_type_bits, Vk.MEMORY_PROPERTY_HOST_VISIBLE_BIT | Vk.MEMORY_PROPERTY_HOST_COHERENT_BIT)\n  memory = Vk.DeviceMemory(device, memory_requirements.size, memory_index; next = Vk.MemoryAllocateFlagsInfo(0; flags = Vk.MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT))\n  unwrap(Vk.bind_buffer_memory(device, buffer, memory, 0))\n\n  # Get a pointer to this memory, so we can write to it.\n  memory_ptr = unwrap(Vk.map_memory(device, memory, 0, sizeof(array)))\n  GC.@preserve array begin\n    data_ptr = pointer(array)\n    unsafe_copyto!(Ptr{Float32}(memory_ptr), data_ptr, length(array))\n  end\n\n  # Get its device address.\n  # Note that this is a device address, not a host address; it should only be used from a shader executing on `device`.\n  buffer_address = Vk.get_buffer_device_address(device, Vk.BufferDeviceAddressInfo(buffer))\n\n  # Create the compute pipeline our shader will be executed with.\n  push_constant_range = Vk.PushConstantRange(stage, 0, 12)\n  pipeline_layout = Vk.PipelineLayout(device, [], [push_constant_range])\n  # Note: the name of the entry point of any shader compiled with SPIRV.jl will always be \"main\".\n  pipeline_info = Vk.ComputePipelineCreateInfo(Vk.PipelineShaderStageCreateInfo(stage, shader, \"main\"), pipeline_layout, 0)\n  ((pipeline, _...), _) = unwrap(Vk.create_compute_pipelines(device, [pipeline_info]))\n\n  # Build the command buffer and record the appropriate commands to invoke our compute shader.\n  command_pool = Vk.CommandPool(device, queue_family_index)\n  (command_buffer, _...) = unwrap(Vk.allocate_command_buffers(device, Vk.CommandBufferAllocateInfo(command_pool, Vk.COMMAND_BUFFER_LEVEL_PRIMARY, 1)))\n  Vk.begin_command_buffer(command_buffer, Vk.CommandBufferBeginInfo())\n  Vk.cmd_bind_pipeline(command_buffer, Vk.PIPELINE_BIND_POINT_COMPUTE, pipeline)\n  # --> This is where we provide our `ComputeData` argument.\n  push_constant = serialize(ComputeData(buffer_address, length(array)), source.info.layout)\n  push_constant_ptr = pointer(push_constant)\n  Vk.cmd_push_constants(command_buffer, pipeline_layout, push_constant_range.stage_flags, push_constant_range.offset, push_constant_range.size, Ptr{Cvoid}(push_constant_ptr))\n  # --------------------------------------------------------\n  # Dispatch as many workgroups as necessary to cover all array elements.\n  workgroup_invocations = prod(source.info.interface.execution_options.local_size)\n  Vk.cmd_dispatch(command_buffer, cld(length(array), workgroup_invocations), 1, 1)\n  Vk.end_command_buffer(command_buffer)\n\n  # Get a queue for submission, then submit the command buffer.\n  queue = Vk.get_device_queue(device, queue_family_index, 0)\n  unwrap(Vk.queue_submit(queue, [Vk.SubmitInfo([], [], [command_buffer], [])]))\n\n  # Wait for all operations to finish, making sure none of the\n  # required resources are cleaned up by the GC before then.\n  # Finally, retrieve the data.\n  GC.@preserve array buffer memory pipeline_layout pipeline command_pool command_buffer push_constant queue begin\n    unwrap(Vk.queue_wait_idle(queue))\n    data_ptr = pointer(array)\n    unsafe_copyto!(data_ptr, Ptr{Float32}(memory_ptr), length(array))\n    Vk.free_command_buffers(device, command_pool, [command_buffer])\n    Vk.unmap_memory(device, memory)\n  end\n  array\nend\n\n# Utility function to find a memory that satisfies all our requirements.\nfunction find_memory_type(physical_device::Vk.PhysicalDevice, type, properties::Vk.MemoryPropertyFlag)\n  memory_properties = Vk.get_physical_device_memory_properties(physical_device)\n  memory_types = memory_properties.memory_types[1:(memory_properties.memory_type_count)]\n  candidate_indices = findall(i -> type & (1 << i) ≠ 0, 0:(memory_properties.memory_type_count - 1))\n  # Make sure we get a host-coherent memory, because we don't want\n  # to bother with flushing and invalidating memory.\n  index = findfirst(i -> in(Vk.MEMORY_PROPERTY_HOST_COHERENT_BIT, memory_types[i].property_flags), candidate_indices)\n  index - 1\nend\n\narray .= range(0.0, 1.0, length(array))\n\nexecute_shader(source, device, queue_family_index, array)","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"I'd like to draw attention to something extremely important. This concerns the following piece of code in execute_shader:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"push_constant = serialize(ComputeData(buffer_address, length(data)), source.info.layout)","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"One may have thought instead to construct a Ref to the push constant, and then convert the Ref into a pointer. That would actually work, in the case where:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"No mutable data is stored inside (as Julia stores pointers to these objects, not their data, for mutable struct fields).\nThe data layout matches exactly with the data layout declared in the shader.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Even if we assume that we do not have mutable data, data layouts may not match.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"To better take a look at it, we'll use About.jl, to display the layout of the Julia structure:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"using About: about\n\nabout(ComputeData)","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We have:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"8 bytes for the UInt64\n4 bytes for the UInt32\n4 extra bytes of padding.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"Totalling a size of 16 bytes.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"The shader we compiled has the following decorations:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"# Note: this snippet uses internals for demonstration purposes.\nusing SPIRV: SPIRV\n\namod = SPIRV.annotate(SPIRV.Module(shader.ir))\namod[amod.annotations]","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"The MemberDecorate(..., ..., Offset, ...) decorations provide offset information for each field of a structure (here, the only structure present in the shader is the one that represents our ComputeData).","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"We have:","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"An offset of 0 bytes for the UInt64 whose size is 8 bytes.\nAn offset of 8 bytes for the UInt32 whose size is 4 bytes.\nIn absence of remaining layout information, we may conclude that the total size equals 12 bytes.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"In this case, the data offsets are identical, therefore memory accesses won't be problematic. But there are cases (notably with non-default layout parameters) where offsets differ, and it is good to be aware of that. To avoid relying on chance, it is advised to serialize the data using the appropriate layout.","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"","category":"page"},{"location":"tutorials/creating_a_shader/","page":"Creating a shader","title":"Creating a shader","text":"This page was generated using Literate.jl.","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Updating-the-SPIR-V-bindings","page":"Developer documentation","title":"Updating the SPIR-V bindings","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"SPIR-V bindings are generated in this package, according to the SPIR-V specification. To update to bindings reflecting a newer version of the specification, run","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"julia --color=yes --project=gen -e 'using Pkg; Pkg.instantiate(); include(\"gen/generator.jl\")'","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Note that this should not be performed by package users. This is only relevant if a maintainer or developer wishes to upgrade the bindings to reflect that of a newer version of the SPIR-V specification, at which point a pull request would be highly appreciated so that everyone gets to enjoy the update.","category":"page"},{"location":"#SPIRV.jl","page":"SPIRV.jl","title":"SPIRV.jl","text":"","category":"section"},{"location":"","page":"SPIRV.jl","title":"SPIRV.jl","text":"Tooling around the manipulation of the SPIR-V binary format defined by the Khronos Group.","category":"page"},{"location":"#Status","page":"SPIRV.jl","title":"Status","text":"","category":"section"},{"location":"","page":"SPIRV.jl","title":"SPIRV.jl","text":"This package is currently a work in progress. The source code and public API may change at any moment. Use at your own risk.","category":"page"},{"location":"","page":"SPIRV.jl","title":"SPIRV.jl","text":"Pages = [\"intro.md\", \"api.md\"]","category":"page"}]
}
